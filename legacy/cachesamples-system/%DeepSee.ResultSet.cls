/* Copyright (c) 2025 by InterSystems Corporation.
   Cambridge, Massachusetts, U.S.A.  All rights reserved.
   Confidential property of InterSystems Corporation. */

Include %DeepSee

/// This class provides an API for executing queries against DeepSee cubes 
/// and viewing the results.<br/>
/// This class extends Zen data model so that it can efficiently
/// work within the Zen MVC framework.
Class %DeepSee.ResultSet Extends %ZEN.DataModel.DataModel [ System = 4 ]
{

/// Debugging flag. If true write out tracing information to the console.
Property %Trace As %Boolean [ InitialExpression = 0 ];

/// Run-time query object that will serve as the source for this result set.
Property %Query As %DeepSee.Query.query [ Internal ];

/// Name of the cube this query is based on.
Property %Cube As %DeepSee.Datatype.string [ Internal ];

/// Canonic (index) name of the cube this query is based on.
Property %CubeKey As %DeepSee.Datatype.string [ Internal ];

/// Query key for the current query.
Property %QueryKey As %DeepSee.Datatype.string [ Internal ];

/// Array of timing and performance statistics for the current query.
Property %Statistics As %DeepSee.Datatype.string [ MultiDimensional ];

/// If true, then use results caching for this query.
Property %UseCache As %Boolean [ InitialExpression = 1 ];

/// If true recompute previously run queries whose data has been updated
/// otherwise return old values.
Property %Recompute As %Boolean [ InitialExpression = 1 ];

/// Holds the number of axes in the current query.
Property %AxisCount As %Integer [ Internal ];

/// Array of named parameters with current values.
/// These are set by the <method>%SetParameterContext</method> method.<br/>
Property %NamedParameters As %Integer [ Internal, MultiDimensional ];

/// This holds the SQL query generated by a DRILLTHROUGH query.
/// Use the <method>%GetListingSQL</method> to get this.
Property %ListingSQL As %String(MAXLEN = 32000) [ Private ];

/// This holds the SQL StatementResult object created by a DRILLTHROUGH query.
/// Use the <method>%GetListingResult</method> to get this.
Property %ListingResult As %SQL.StatementResult [ Private ];

/// List of fields to display for a DRILLTHROUGH query.
/// Use the <method>%GetListingResult</method> to get this.
Property %ListingFields As %List [ Private ];

/// Indicates this is being run within the context of a plugin calculation.
Property %IsPlugIn As %Integer [ InitialExpression = 0 ];

/// Used in plugin concurrency protection
Property %PlugInListingKey As %String;

/// Used in plugin concurrency protection
Property %PlugInContextName As %String;

/// Used in plugin concurrency protection
Property %PlugInContextProp As %String;

/// Used in plugin concurrency protection
Property %PlugInFilters As %ZEN.Datatype.string(XMLPROJECTION = "NONE") [ MultiDimensional, Transient ];

/// Used in plugin concurrency protection
Property %PlugInArguments As %ZEN.Datatype.string(XMLPROJECTION = "NONE") [ MultiDimensional, Transient ];

/// If set, this is the name of a listing within the current cube to use for detail listings.
Property listing As %String(MAXLEN = 255);

/// Number of rows in the current listing query.
Property listingRows As %Integer [ InitialExpression = 0 ];

/// Number of rows within a listing query "page".
Property listingPageSize As %Integer [ InitialExpression = 1000 ];

/// Current "page" of listing query.
Property listingPage As %Integer [ InitialExpression = 1 ];

/// Formatting string to apply to listing results.
Property listingFormatList As %String(MAXLEN = 5000);

/// Store the keys of any locks taken out by this query.
Property %LockKeys As %String [ MultiDimensional ];

/// Store the keys of any locks taken out by ancestors of this query in a lookup index. 
/// The presence of locks in this index will mean the locks are already protected at the time 
/// of execution for this ResultSet.
Property %AncestorLockKeys As %String [ MultiDimensional ];

/// Lock mode determines whether this resultset is operating in read or write mode.
/// Do not change this property directly - use <method>%SetLockMode</method>.
Property %LockMode As %String [ InitialExpression = "exclusive" ];

/// Current state of the resultset locks.
Property %LocksEngaged As %Boolean [ InitialExpression = 0 ];

/// If true, a private copy of the resultset is available.
Property %UseLocal As %Boolean [ InitialExpression = 0 ];

/// This points to the global location that has the results portion of the resultset.
Property %ResultCacheLocation As %String [ InitialExpression = {$Name($$$DeepSeeResultsGLVN)} ];

/// This points to the global location that has the axis portion of the resultset.
Property %AxisCacheLocation As %String [ InitialExpression = {$Name($$$DeepSeeAxisGLVN)} ];

/// A unique session key for the current resultset.
Property %SessionKey As %String [ InitialExpression = {$I($$$DeepSeeLocalResultsGLVN("session"))} ];

/// Container for the subquery resultsets of this execution.
Property %SubqueryResultSets As %DeepSee.ResultSet [ MultiDimensional ];

/// If true, the private copy of the resultset will not be deleted after the resultset is closed
Property %KeepLocalResults As %Boolean [ InitialExpression = 0 ];

/// Convenience method.<br/>
/// Creates a result set, prepares the query <var>pMDX</var>, and executes it.<br/>
/// Returns an instance of the result set.
ClassMethod %ExecuteDirect(pMDX As %String, ByRef pParms, Output pSC As %Status, pAsync = 0, pWait = 1) As %DeepSee.ResultSet
{
	Set pSC = $$$OK
	Set tRS = ""
	Try {
		Set tRS = ..%New()
		Set pSC = tRS.%PrepareMDX(pMDX)
		If $$$ISERR(pSC) Quit

		// DP-403772 - Add option to execute asynchronously
		If 'pAsync {
			Set pSC = tRS.%Execute(.pParms)
			If $$$ISERR(pSC) Quit
		}
		Else {
			Set pSC = tRS.%ExecuteAsynch(,.pParms,pWait)
			If $$$ISERR(pSC) Quit
		}
	}
	Catch(ex) {
		Set pSC = ex.AsStatus()
		Set tRS = ""
	}
	Quit tRS
}

/// Given the text of a DeepSee MDX query, <var>pMDX</var>, 
/// parse it, convert it to a DeepSee run-time query object, and
/// prepare it so that it can then be executed.<br/>
/// <var>pVariables</var> is an optional list of pivot variable names and their current values.
/// These are substituted for any pivot variable references within the query before it is parsed.<br/>
/// <var>pResolvedMDX</var> is the query text after any pivot variable references have been resolved.
Method %PrepareMDX(pMDX As %String = "", ByRef pVariables, Output pResolvedMDX) As %Status
{
	Set tSC = $$$OK
	Try {
		$$$dsTrackFeature("ResultSet")		// DTB393
		
		Set tMDX = pMDX
		
		// +DTB739 - Initialize on every prepare in case this is a new query in a reused resultset!
		Set tSC = ..%InitializeResultSet()
		If $$$ISERR(tSC) Quit
		// -DTB739
		
		If '$D(%dsUserName) {
			// DTB682 - Set special environment token for callbacks
			New %dsUserName
			Set %dsUserName = $UserName
		}
		
		Set ..%Query = ""
		Set ..%QueryKey = ""
		Set ..%Cube = ""
		Set ..%CubeKey = ""
		Set ..%AxisCount = ""
		Set ..%ListingSQL = ""
		Set ..%ListingResult = ""
		Set ..%ListingFields = ""

		// parse the query
		Set tQuery = ##class(%DeepSee.Query.query).%New()
		Merge tQuery.%NamedParameters = ..%NamedParameters

		// JMD1507: translate pivot variable names to lower case
		Set k = $O(pVariables(""))
		While (k'="") {
			Set tVariables($$$LOWER(k)) = $G(pVariables(k))
			Set k = $O(pVariables(k))
		}
		// DTB554 - Set variable values into the query object
		Set tSC = tQuery.%SetVariables(.tVariables)
		If $$$ISERR(tSC) Quit

		// DTB554 - Resolve pivot variables in the provided MDX statement
		Set tSC = ##class(%DeepSee.Query.query).%ResolveVariablesInText(.tMDX,.tVariables)
		If $$$ISERR(tSC) Quit
		Set pResolvedMDX = tMDX

		Set tSC = ..%ParseMDX(tMDX,tQuery)
		If $$$ISERR(tSC) Quit

		// n.b., this will set %Query
		Set tSC = ..%PrepareObject(tQuery)
		If $$$ISERR(tSC) Quit
		
		// DTB739 - Immediately store the original query text once we have the filing keys
		// DTB853 - Store the original text with variables resolved
		If (..%CubeKey'="")&&(..%Query.%QueryKey'="") {
			Set $$$DeepSeeResultsGLVN(..%CubeKey,..%Query.%QueryKey,"query",0) = pResolvedMDX
		}
		
		// DTB739 - Set lock keys
		Set tSC = ..%SetLockKeys()
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
}

/// Given a DeepSee run-time query, <var>pQuery</var>, 
/// prepare it so that it can then be executed.
Method %PrepareObject(pQuery As %DeepSee.Query.query, ByRef pVariables) As %Status
{
	Set tSC = $$$OK
	Try {
		Set ..%Query = pQuery
		Set ..%QueryKey = ""
		Set ..%Cube = ""
		Set ..%CubeKey = ""
		Set ..%AxisCount = ""
		Set ..%ListingSQL = ""
		Set ..%ListingResult = ""
		Set ..%ListingFields = ""

		Set ..%Query.useCache = ..%UseCache
		Set ..%Query.recompute = ..%Recompute
		If ((pQuery.queryType="CREATE")||(pQuery.queryType="DROP")) {
			Set ..%Cube = ..%Query.cube
			Set ..%CubeKey = $$$DeepSeeIndex(..%Cube)
			Quit
		}

		Set tSC = ..%Query.%Prepare()
		If $$$ISERR(tSC) Quit

		// Note: key is not available until ExecuteParameters is called
		Set ..%QueryKey = ..%Query.%QueryKey
		Set ..%Cube = ..%Query.cube
		Set ..%CubeKey = $$$DeepSeeIndex(..%Cube)
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Given a DeepSee query key, <var>pQueryKey</var>, 
/// (returned by a previous query prepare),
/// restore the state of the query so that it can
/// be executed.<br/>
Method %PrepareKey(pCubeName As %String = "", pQueryKey As %String = "", ByRef pParms, pOriginalMDX As %String = "") As %Status
{
	Set tSC = $$$OK
	Try {
		// DTB739 - Initialize on every prepare in case this is a new query in a reused resultset!
		Set tSC = ..%InitializeResultSet()
		If $$$ISERR(tSC) Quit
		
		If '$D(%dsUserName) {
			// DTB682 - Set special environment token for callbacks
			New %dsUserName
			Set %dsUserName = $UserName
		}
		
		If ((pCubeName="")||(pQueryKey="")) {
			Set tSC = $$$ERROR($$$GeneralError,"Missing cube or query key in %PrepareKey")
			Quit
		}
		
		#; check status
		Set tStatus = ..%GetQueryStatus(pCubeName,pQueryKey)
		If (tStatus < 30) {
			// JMD1156
			Set tSC = $$$ERROR($$$GeneralError,"ExecuteAxes must be called before PrepareKey")
			Quit
		}

		// + WAL266 -- check to see if cache is up to date. If not and if the caller specifies
		//             that we should run %PrepareMDX in this case do so
		// DTB739 - Always do this, preparation is cheap and %PrepareMDX will re-initialize the state
		If $D($$$DeepSeeResultsGLVN($$$DeepSeeIndex(pCubeName),pQueryKey,"query",0)) {
			// DTB847 - Try to fetch from the 0 node, which will be the direct input. If that does not exist, 
			// grab the keyText, which should always exist if there is a key to prepare
			Set pOriginalMDX = $G($$$DeepSeeResultsGLVN($$$DeepSeeIndex(pCubeName),pQueryKey,"query",0))
		}
		Else {
			Set pOriginalMDX = $G($$$DeepSeeResultsGLVN($$$DeepSeeIndex(pCubeName),pQueryKey,"query","keyText"))		// DTB739 - Look at the original query text
		}
		
		If pOriginalMDX'="" {
			Set tSC = ..%PrepareMDX(pOriginalMDX)
			If $$$ISERR(tSC) Quit
			
			// + DTB904 - Use the parameters passed in to create this specific query or look for previous parameters used if only the key is supplied, then execute parameters 
			If $D(pParms) {
				Merge tParms = pParms 
			}
			Else {
				Merge tParms = $$$DeepSeeResultsGLVN($$$DeepSeeIndex(pCubeName),pQueryKey,"params")
			}
			Set tSC = ..%ExecuteParameters(.tParms)
			If $$$ISERR(tSC) Quit
			// - DTB904
			
			Quit	
		}
		Else {
			Set tSC = $$$ERROR($$$GeneralError,"Could not retrieve query text for key: " _ pCubeName _ ":" _ pQueryKey)
			Quit
		}
		// - WAL266
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Specify which listing to use for detail listings.
Method %SetListing(pListing As %String) As %Status
{
	Set ..listing = pListing
	Quit $$$OK
}

/// Take a pre-defined set of named parameters and apply them to MDX
/// queries executed against this result set.<br/>
/// This makes it possible to add defined parameters to a query without 
/// adding them to the query text. This is different than supplying run-time values
/// for parameters when executing the query.<br/>
/// The named parameter context is an array subscripted by UPPER CASE parameter
/// name and parameter attribute (which can be "VALUE","TYPE",or "CAPTION").<br/>
/// For example:<br/>
/// pContext("CITY","VALUE") = "New York"<br/>
/// Call this before preparing a query.
Method %SetParameterContext(ByRef pContext) As %Status
{
	Set tSC = $$$OK
	Try {
		Kill ..%NamedParameters
		Merge ..%NamedParameters = pContext
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Return the DeepSee run-time query object currently in use
/// as the source for this result set.
Method %GetQuery() As %DeepSee.Query.query
{
	Quit ..%Query
}

/// Return the current Query Key for this Result Set.
/// The result set must be prepared before calling this.
Method %GetQueryKey() As %String
{
	Quit ..%QueryKey
}

/// Return the name of the cube this ResultSet is executing against.
/// The result set must be prepared before calling this.
Method %GetCubeName() As %String
{
	Quit ..%Cube
}

/// Output the cube last data update date in the XMLA format
Method %GetLastDataUpdate() As %String
{
	Set tCubeKey = ..%CubeKey
	Set tLastDataUpdate = $G($$$DeepSeeUpdateQueue("cubes",tCubeKey,"lastDataUpdate"))		// DTB422
	If (tLastDataUpdate'="") {
		// format is: "2009-06-19T15:55:31"
		Set tLastDataUpdate = $TR($ZDT(tLastDataUpdate,3)," ","T")
	}
	Quit tLastDataUpdate
}

/// Output the cube last schema update date in the XMLA format
Method %GetLastSchemaUpdate() As %String
{
	Set tCubeKey = ..%CubeKey
	Set tLastSchemaUpdate = $G($$$DeepSeeMetaGLVN("cubes",tCubeKey,"lastSchemaUpdate"))
	If (tLastSchemaUpdate'="") {
		// format is: "2009-06-19T15:55:31"
		Set tLastSchemaUpdate = $TR($ZDT(tLastSchemaUpdate,3)," ","T")
	}
	Quit tLastSchemaUpdate
}

/// Prepare and execute the listing query for the current MDX statement.
/// Return an SQL ResultSet that can be used to iterate over the listing.
/// If <var>pFieldList</var> is not empty, then it is a $List of fields that
/// should be selected and displayed from the result set.
Method %GetListingResultSet(Output pRS As %SQL.StatementResult, Output pFieldList As %List) As %Status
{
	Set tSC = $$$OK
	Set pRS = ..%ListingResult
	Set pFieldList = ..%ListingFields
	If (pRS="") {
		Set tSC = $$$ERROR($$$GeneralError,"No listing result available")
	}
	Quit tSC
}

/// Return the SQL statement needed to drill into the source table for a DRILLTHROUGH statement.
/// This may return the name of the DataConnector class if that is how the listing is defined.
Method %GetListingSQL() As %String
{
	Quit ..%ListingSQL
}

/// Test if this is a DRILLTHROUGH statement.
Method %IsDrillThrough() As %Boolean
{
	Set tIsDrill = 0
	If ((..%CubeKey'="")&&(..%QueryKey'="")) {
		// JMD1381 check for slave query
		Set tQueryKey = ..%QueryKey
		Set tIsSlave = ($E(tQueryKey,1,6)="SLAVE:")
		If (tIsSlave) {
			Set tQueryKey = $E(tQueryKey,7,*)
		}
		Set tIsDrill = $G(@..%ResultCacheLocation@(..%CubeKey,tQueryKey,"queryType")) = "DRILLTHROUGH"
	}
	Quit tIsDrill
}

/// Return the text of the query currently associated with this result set.
/// This text is generated from the query parse tree and represents the canonic form
/// of the query.
Method %GetQueryText() As %String
{
	Set tText = ""
	If ((..%CubeKey'="")&&(..%QueryKey'="")) {
		// JMD1381 check for slave query
		Set tQueryKey = ..%QueryKey
		Set tIsSlave = ($E(tQueryKey,1,6)="SLAVE:")
		If (tIsSlave) {
			Set tQueryKey = $E(tQueryKey,7,*)
		}
		Set tText = $G(@..%ResultCacheLocation@(..%CubeKey,tQueryKey,"query",1))
	}
	Quit tText
}

/// Given a cube name and a query key (as returned by the <method>%ExecuteAsync</method>)
/// return the current status of the query.<br/>
/// 0 indicates that nothing has been done; 100 indicates that 
/// query execution is complete and that results are ready; a value
/// in between means that work is ongoing.
ClassMethod %GetQueryStatus(pCubeName As %String, pQueryKey As %String, Output pPercentComplete As %Double, Output pSC As %Status, Output pPendingResults As %Boolean) As %Integer
{
	// JMD900
	Set pPendingResults = 0

	Set pSC = $$$OK
	Set pPercentComplete = ""
	Quit:pCubeName="" 0
	Quit:pQueryKey="" 0
	Set tCubeIndex = $$$DeepSeeIndex(pCubeName)

	// JMD1381 check for slave query
	Set tIsSlave = ($E(pQueryKey,1,6)="SLAVE:")
	If (tIsSlave) {
		Set pQueryKey = $E(pQueryKey,7,*)
	}

	// If query has an error, report it
	Set pSC = $G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"error"),$$$OK)
	If $$$ISERR(pSC) {
		Set pPercentComplete = 100		
		Quit 100
	}

	Set tStatus = $G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"status"))
	If (tStatus = "") {
		// not ready yet OR someone killed the results global (don't log that!)
		// DTB987 - If a querykey exists, the results global should have data in the "query" node.
		// create a copy and remove the "query" node to see if the remainder has data before 
		// throwing the error.
		Merge tQueryResult = $$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey)
		Kill tQueryResult("query")
		
		If $D(tQueryResult) {
			Do ##class(%DeepSee.Utils).%WriteToLog("ResultSet","GetQueryStatus no status found")
		}
		Quit 0
	}
	Set tStatus = +tStatus
	Set tCellTaskGroup = $G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"cellTaskGroup"))
	Set tAxesTaskGroup = $G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"axesTaskGroup"))
	Set tExecTaskGroup = $G($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"execTaskGroup"))		// DTB880

	// JMD1156
	If ((tStatus < 30)&&(tAxesTaskGroup'="")) {
		If ($G($$$DeepSeeTaskGroupGLVN(tAxesTaskGroup,"errorCode"))'="") {
			// error: stop
			Set tStatus = 100
			Set pPercentComplete = 100
			Set pSC = $$$ERROR($$$GeneralError,"Error in background processing: " _ $system.Status.GetErrorText($G($$$DeepSeeTaskGroupGLVN(tAxesTaskGroup,"errorCode"))))		// DTB
			Set $$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"status") = tStatus
			Set $$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"error") = pSC
			Quit tStatus
		}
		
		// find approx total number of items in all axes
		Set tMbrCount = 0
		Set tAxisNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"axis",""),1,tAxisKey)
		While (tAxisNo'="") {
			Set tLastKey = $O($$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"axes",""),-1)
			Set tMbrCount = tMbrCount + tLastKey
			Set tAxisNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"axis",tAxisNo),1,tAxisKey)
		}
		Set pPercentComplete = tMbrCount
	}
	ElseIf (tCellTaskGroup'="") {
		If ($G($$$DeepSeeTaskGroupGLVN(tCellTaskGroup,"errorCode"))'="") {
			// error: stop
			Set tStatus = 100
			Set pPercentComplete = 100
			Set pSC = $$$ERROR($$$GeneralError,"Error in background processing: " _ $system.Status.GetErrorText($G($$$DeepSeeTaskGroupGLVN(tCellTaskGroup,"errorCode"))))		// DTB
			Set $$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"status") = tStatus
			Set $$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"error") = pSC
			Quit tStatus
		}

		Set tCount = +$G($$$DeepSeeTaskGroupGLVN(tCellTaskGroup,"count"))
		Set tComplete = +$G($$$DeepSeeTaskGroupGLVN(tCellTaskGroup,"complete"))
		Set:tCount>0 pPercentComplete = (tComplete/tCount)*100
	}
	ElseIf (tStatus > 50) {
		Set pPercentComplete = 100

		// JMD900: test for pending results
		Set pPendingResults = ''$D($$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"pending"))
	}	
	
	If (tExecTaskGroup'="") {
		// DTB880 - Check the background execute task to verify there is no error
		If ($G($$$DeepSeeTaskGroupGLVN(tExecTaskGroup,"errorCode"))'="") {
			// error: stop
			Set tStatus = 100
			Set pPercentComplete = 100
			Set pSC = $$$ERROR($$$GeneralError,"Error in background processing: " _ $system.Status.GetErrorText($G($$$DeepSeeTaskGroupGLVN(tExecTaskGroup,"errorCode"))))		// DTB
			Set $$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"status") = tStatus
			Set $$$DeepSeeResultsGLVN(tCubeIndex,pQueryKey,"error") = pSC
			Quit tStatus
		}
	}
	Quit tStatus
}

/// Given a cube name and a query key (as returned by the <method>%ExecuteAsync</method>)
/// return the number of result cells that are returned by the query.<br/>
Method %GetCellCount(pCubeName As %String, pQueryKey As %String, Output pSC As %Status) As %Integer
{
	Set pSC = $$$OK
	Quit:pCubeName="" 0
	Quit:pQueryKey="" 0
	Set tCubeIndex = $$$DeepSeeIndex(pCubeName)

	// JMD1381 check for slave query
	Set tIsSlave = ($E(pQueryKey,1,6)="SLAVE:")
	If (tIsSlave) {
		Set pQueryKey = $E(pQueryKey,7,*)
	}

	// If query has an error, report it
	Set pSC = $G(@..%ResultCacheLocation@(tCubeIndex,pQueryKey,"error"),$$$OK)
	Quit +$G(@..%ResultCacheLocation@(tCubeIndex,pQueryKey,"cells"))
}

/// Cancel the query, if running, specified by the cube name and query key.
ClassMethod %CancelQuery(pCubeName As %String, pQueryKey As %String) As %Status
{
	Set tSC = $$$OK
	Try {
		If ((pCubeName="")||(pCubeName="")) {
			Set tSC = $$$ERROR($$$GeneralError,"Query not specified")
			Quit
		}
		
		// DTB788 - Quit out if the query is complete, nothing to cancel!
		If (..%GetQueryStatus(pCubeName,pQueryKey)=100) {
			Quit
		}
		
		Set tCubeName = $$$UPPER(pCubeName)
		Set tStatus = +$G($$$DeepSeeResultsGLVN(tCubeName,pQueryKey,"status"))
		
		// DTB719 - Look at all the task subgroups and remove any remaining tasks
		Set tAxesTaskGroup = $G($$$DeepSeeResultsGLVN(tCubeName,pQueryKey,"axesTaskGroup"))		
		Set tExecTaskGroup = $G($$$DeepSeeResultsGLVN(tCubeName,pQueryKey,"execTaskGroup"))
		Set tCellTaskGroup = $G($$$DeepSeeResultsGLVN(tCubeName,pQueryKey,"cellTaskGroup"))
		
		If (tCubeName'="")&&(pQueryKey'="") {		// DTB167 - Run whenever the global references will be defined
			// DTB168 - Attempt to clear the reserved axes. Do not proceed if this fails!
			Set tSC = ##class(%DeepSee.Query.query).%ReleaseReservedAxes(tCubeName,pQueryKey)
			
			// DTB602 - Remove top zprocessing node
			Kill $$$DeepSeeResultsGLVN(tCubeName,pQueryKey,"zprocessing")
			
			// DTB168 - Preserve the original text. This is used when determining if the query had an error in the last execution
			Set tQueryText = $G($$$DeepSeeResultsGLVN(tCubeName,pQueryKey,"query",0))
			
			//Kill $$$DeepSeeTasksGLVN		// DTB719 - Do not kill the entire tasks global!
			Do:(tAxesTaskGroup'="") ##class(%DeepSee.WorkMgr).%DestroyTaskGroup(tAxesTaskGroup)
			Do:(tExecTaskGroup'="") ##class(%DeepSee.WorkMgr).%DestroyTaskGroup(tExecTaskGroup)
			Do:(tCellTaskGroup'="") ##class(%DeepSee.WorkMgr).%DestroyTaskGroup(tCellTaskGroup)

			Kill $$$DeepSeeResultsGLVN(tCubeName,pQueryKey)
			
			// DTB168 - Replace some values to signal the query has not had a successful execution
			Set $$$DeepSeeResultsGLVN(tCubeName,pQueryKey,"error") = $$$ERROR($$$GeneralError,"Query cancelled")
			Set:(tQueryText'="") $$$DeepSeeResultsGLVN(tCubeName,pQueryKey,"query",0) = tQueryText
			Set $$$DeepSeeResultsGLVN(tCubeName,pQueryKey,"status") = 100		// DTB167 - Query is complete, with an error
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Instance method version of <method>%GetQueryStatus</method>.
Method %GetStatus(Output pPercentComplete As %Double, Output pSC As %Status, Output pPendingResults As %Boolean) As %Integer
{
	Set pSC = $$$OK
	Set pPendingResults = 0
	Set tStatus = 0
	
	Try {
		If ((..%Query.queryType="CREATE")||(..%Query.queryType="DROP")) {
			Set pPercentComplete = 100
			Set tStatus = 100
			Quit
		}
		
		If (..%UseLocal) {
			// DTB739 - There will only be a local copy if the status was 100 previously
			Set tCubeIndex = $$$DeepSeeIndex(..%GetCubeName())
			Set tQueryKey = ..%QueryKey
			
			Set tStatus = 100
			Set pPercentComplete = 100
			If (tCubeIndex'="")&&(tQueryKey'="") {
				Set pPendingResults = ''$D($$$DeepSeeLocalResultsGLVN(..%SessionKey,tCubeIndex,tQueryKey,"pending"))
			}
		}
		Else {
			Set tStatus = ..%GetQueryStatus(..%Cube,..%QueryKey,.pPercentComplete,.pSC,.pPendingResults)
			If $$$ISERR(pSC) Quit		// DTB873 - Nothing more to do if there was an error, return this status
		
			// +DTB739 - Switch to read mode if the query is complete		
			If (tStatus=100)&&('pPendingResults) {
				If '..%AcquireLocks(.pSC,"shared") {
					// DTB868 - The query is done but this resultset couldn't get the read lock 
					// because the writer hasn't released it yet
					Set tStatus = 90 
				}
				Else {

					Set pSC = ..%SwitchToLocalCache()
					If $$$ISERR(pSC) Quit
					
					// DTB868 - No need for locks anymore if the local cache is used
					Do ..%ReleaseLocks()
				}
			}
			// -DTB739
		}
	}
	Catch ex {
		Set pSC = ex.AsStatus()
	}

	// + WAL049 -- don't update ..%QueryKey here
	Quit tStatus
	// - WAL049
}

/// Return the set of named parameters values defined by the query.
Method %GetParameterInfo(Output pParms) As %Status
{
	Set tSC = $$$OK
	Try {
		Kill pParms
		If '$IsObject(..%Query) {
			Set tSC = $$$ERROR($$$GeneralError,"Result set not prepared")
			Quit
		}
		Set tSC = ..%Query.%GetParameterInfo(.pParms)
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Execute the current prepared query for this ResultSet.<br/>
/// If defined, <var>pParms</var> is an array of parameter values
/// subscripted by parameter name (case-insensitive). These are supplied
/// to the query and override the default values for any parameters
/// defined by the query.
Method %Execute(ByRef pParms) As %Status
{
	Set tSC = $$$OK
	$$$dsSetLogging
	
	Try {
		// DTB980 - Add timers
		$$$dsSetLogging
		$$$dsStartTimer
		
		// DTB868 - This is a single-process request. Before beginning actual work, turn off useAgents. 
		// The current setting will be restored on exit
		If $IsObject(..%Query) {
			// DTB874 - This could be called without a valid %Query if %Prepare fails. 
			Set tUseAgents = ..%Query.useAgents
			Set ..%Query.useAgents = 0
		}
		
		// DTB788 - Execute must be operating on the common cache!
		Set tSC = ..%SwitchToCommonCache()
		If $$$ISERR(tSC) Quit
		
		// +DTB739 - Take out write locks before executing
		Do ..%ReleaseLocks()
		
		// + DTB847 - Reset the lock keys after resolving the parameters
		Do ..%ClearLockKeys()
		Set tSC = ..%ExecuteParameters(.pParms)
		If $$$ISERR(tSC) Quit
		
		// DTB868 - Update the keys found previously while setting lock keys
		// DTB943 - This execution will be waiting by definition
		Do ..%SetLockKeys(1,1)
		// - DTB847
		
		Set tSC = ..%SetLockMode("exclusive")
		If $$$ISERR(tSC) Quit
		
		Set tTries = 0
		While '..%LocksEngaged&&(tTries<100) {
			Set tTries = tTries+1
			Do ..%AcquireLocks(.tSC)
			
			If '..%LocksEngaged {
				Hang 1
			}
		}
		// -DTB739

		$$$dsSetAppInfo($LB($$$DeepSeeIndex(..%GetCubeName()),..%QueryKey))		// DP-419418 - Register with the activity monitor

		
		If ((..%Query.queryType = "CREATE")||(..%Query.queryType = "DROP")) {
			Set tSC = ..%ExecuteSessionCommand()
			Quit
		}
		
		// +DTB739 - %InitializeResultsCache is now separated from %ExecuteParameters
		Lock +^DeepSee.Query("InitializeResultsCache",..%QueryKey):10
		If ('$Test) {
			Set tSC = $$$ERROR($$$GeneralError,"Unable to obtain InitializeResultsCache lock")
			Quit
		}
		
		Set tSC = ..%Query.%InitializeResultsCache()
		Lock -^DeepSee.Query("InitializeResultsCache",..%QueryKey)
		If $$$ISERR(tSC) Quit
		// -DTB739
		
		Set tSC = ..%ExecuteAxes()
		If $$$ISERR(tSC) Quit

		Set tSC = ..%ExecuteCells()
		If $$$ISERR(tSC) Quit
		
		If (..%Query.queryType = "DRILLTHROUGH") {
			Set tSC = ..%ExecuteListing()
			If $$$ISERR(tSC) Quit
		}

		// JMD1451: Test for pending results...
		Set tQueryStatus = ..%GetQueryStatus(..%Cube,..%QueryKey,.tPctComplete,.tQSC,.tPending)
		While (tPending) {
			Set tSC = ..%UpdatePendingResults(.tPending)
			If $$$ISERR(tSC) Quit
			Hang:tPending 1
		}
		
		Do ..%RunQueryAuditCode()  	// DTB065
		
		// DTB788 - Locks can be switched with a single call
		Do ..%AcquireLocks(.tSC,"shared")
		If $$$ISERR(tSC)
		
		Do ..%GetStatus()		// DTB788 - This will convert the resultset to a local reader if the query is complete
		
		If ..%LocksEngaged {
			// DTB868 - This method should not exit without releasing locks
			Do ..%ReleaseLocks()
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	
	If $IsObject(..%Query)&&($G(tUseAgents)'="") {		// DTB874
		// DTB868 - Restore the useAgents setting
		Set ..%Query.useAgents = tUseAgents
	}
	
	$$$dsStopTimer		// DTB980
	
	Quit tSC
}

/// Perform a complete execution of the ResultSet using
/// background agents.<br/>
/// The query must be prepared before calling this method.<br/>
/// If defined, <var>pParms</var> is an array of parameter values
/// subscripted by parameter name (case-insensitive). These are supplied
/// to the query and override the default values for any parameters
/// defined by the query.<br/>
/// If <var>pWait</var> is true, wait for the query to complete execution before
/// returning.<br/>
/// If <var>pAxesOnly</var> is true, then only execute the axes for the query.
Method %ExecuteAsynch(Output pQueryKey As %String, ByRef pParms, pWait As %Boolean = 0, pAxesOnly As %Boolean = 0, pAxesQuery As %String = "") As %Status
{
	Set tSC = $$$OK
	$$$dsSetLogging
	
	Try {
		// DTB980 - Add timers
		$$$dsSetLogging
		$$$dsStartTimer
		
		If '$IsObject(..%Query) {
			Set tSC = $$$ERROR($$$GeneralError,"Result set not prepared")
			Quit
		}
		
		// DTB943 - Any adjustments that need to occur in tWait must happen early, since the locking
		// scheme is made aware of whether or not this managing process will wait.
		Set tWait = pWait		// DTB877 - This might get changed, don't change the input
		If (..%Query.queryType = "DRILLTHROUGH") {
			// DTB877 - The listing must wait for the MDX portion of the query to complete. 
			// Signal the wait code below which clears the locks and allows background processes to
			// continue under their own protection.
			Set tWait = 1
		}
		
		// DTB788 - Execute must be operating on the common cache!
		Set tSC = ..%SwitchToCommonCache()
		If $$$ISERR(tSC) Quit
		
		// +DTB739 - Take out write locks before executing
		Do ..%ReleaseLocks()
		
		// + DTB847 - Reset the lock keys after resolving the parameters
		Do ..%ClearLockKeys()
		Set tSC = ..%ExecuteParameters(.pParms)
		If $$$ISERR(tSC) Quit
		Do ..%SetLockKeys(1,tWait)		// DTB868 - Update the keys found previously while setting lock keys		// DTB943 - Add tWait
		// - DTB847
		//Set pAxesQuery = ..%Query.%ToString()		// DTB876 - Do *not* pull the processed query text
		
		Set tSC = ..%SetLockMode("exclusive")
		If $$$ISERR(tSC) Quit
		
		// DTB868 - Slave mechanism is removed
		If '..%AcquireLocks(.tSC) {
			// A write lock could not be obtained; switch to attempting a read lock and stop trying to execute.
			// DP-432207 - In the case where the caller requests to wait for results, instruct the request to
			// wait for a successful read lock.
			Do ..%AcquireLocks(.tSC,"shared",$S(tWait:0,1:-1))
			If $$$ISERR(tSC) Quit
			
			Set:(..%QueryKey="") ..%QueryKey = ..%Query.%CreateResultKey()		// DTB868 - Should already be set, but make sure it is!
			Quit
		}
		// -DTB739
		If $$$ISERR(tSC) Quit		// DTB788
		
		$$$dsSetAppInfo($LB($$$DeepSeeIndex(..%GetCubeName()),..%QueryKey))		// DP-419418 - Register with the activity monitor
		
		
		// DTB847 - Protect future references to this variable. The SLAVE key code is removed,
		// this prevents errors when checking this local variable.
		Set tIsWriter = (..%LockMode="exclusive")		// DTB868 - The slave mechanism is replaced with resultsets that are locked writers
		
		// +DTB739 - %InitializeResultsCache is now separated from %ExecuteParameters
		Lock +^DeepSee.Query("InitializeResultsCache",..%QueryKey):10
		If ('$Test) {
			Set tSC = $$$ERROR($$$GeneralError,"Unable to obtain InitializeResultsCache lock")
			Quit
		}
		
		Set tSC = ..%Query.%InitializeResultsCache()
		Lock -^DeepSee.Query("InitializeResultsCache",..%QueryKey)
		If $$$ISERR(tSC) Quit
		// -DTB739
		
		If ((..%Query.queryType = "CREATE")||(..%Query.queryType = "DROP")) {
			// do not use async
			Set tSC = ..%ExecuteSessionCommand()
			Quit
		}
		ElseIf (..%Query.queryType = "DRILLTHROUGH") {
			If (tIsWriter) {
				Set tSC = ..%Query.%ExecuteAsynch(1,.tTaskGroupId,,,.pParms)		// DTB882 - Pass parameters down to the query
				If $$$ISERR(tSC) Quit
			}
		}
		Else {
			If (tIsWriter) {
				// DTB882 - Pass parameters down to the query
				Set tSC = ..%Query.%ExecuteAsynch(tWait,.tTaskGroupId,pAxesOnly,pAxesQuery,.pParms)		// DTB877 - Use local
				If $$$ISERR(tSC) Quit
			}
		}
		
		If tIsWriter&&(tWait) {		// DTB877 - Use the scoped variable
			// DTB943 - There is no longer a need to release locks while waiting for the 
			// background execution. If waiting, this process is holding the locks that will protect 
			// the resources being acted on by the workers.
			
			// DTB704 - This is now handled by the %DeepSee.WorkMgr
			Set tSC = ##class(%DeepSee.WorkMgr).%WaitForTaskGroup(tTaskGroupId,.tWaitComplete)
			If $$$ISERR(tSC) Quit		// DTB788
			
			If ('pAxesOnly) {
	  			Set ..%Query.%Statistics("Cells") = +$G(^IRIS.Temp.DeepSeeUpdate($namespace,tTaskGroupId,"Cells"))
	  			Set ..%Query.%Statistics("Calcs") = +$G(^IRIS.Temp.DeepSeeUpdate($namespace,tTaskGroupId,"Calcs"))
				Kill ^IRIS.Temp.DeepSeeUpdate($namespace,tTaskGroupId,"Cells")
				Kill ^IRIS.Temp.DeepSeeUpdate($namespace,tTaskGroupId,"Calcs")
				Set tTaskGroupId = ""
			}
			
			// + DTB868 - Pick back up as a reader
			Do ..%AcquireLocks(.tSC,"shared")
			If $$$ISERR(tSC) Quit
			// - DTB868
		}
		
		If (..%Query.queryType = "DRILLTHROUGH") {
			If +$G(tWaitComplete) {
			// DTB877 - This needs to occur outside the write lock to make sure the MDX portion is complete
				Set tSC = ..%ExecuteListing()
				If $$$ISERR(tSC) Quit
			}
			Else {
				// DTB943 - Throw an error if the execute task has not reported as complete
				Set tSC = $$$ERROR($$$GeneralError,"SQL Listing could not be executed, MDX resultset execution did not complete.")
				Quit
			}
		}
		
		If (..%GetStatus()<100) {
			// DTB868 - This query is not complete. Release locks so this resultset will 
			// not interfere with anything until it checks back in
			Do ..%ReleaseLocks()
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Set pQueryKey = ..%QueryKey		// DTB943 - Set the output so it is never undefined on return
	
	$$$dsStopTimer		// DTB980
	
	If ($$$ISERR(tSC)&&..%LocksEngaged) {
		// DP-405378 - Make sure locks are released if there is an error in execution that skips the 
		// expected release of the locks.
		Do ..%ReleaseLocks()
	}
	
	Quit tSC
}

/// Apply the array of parameter values to the currently prepared query.
Method %ExecuteParameters(ByRef pParms) As %Status
{
	Set tSC = $$$OK
	Try {
		If '$IsObject(..%Query) {
			Set tSC = $$$ERROR($$$GeneralError,"Result set not prepared")
			Quit
		}
		Set tSC = ..%Query.%ExecuteParameters(.pParms)
		If $$$ISERR(tSC) {
			// DTB615 - Return the query key to support cleanup
			Set ..%QueryKey = ..%Query.%QueryKey 
			Quit
		}
		
		Set ..%QueryKey = ..%Query.%QueryKey 
		
		If $D(pParms) {
			// DTB904 - Log the parameters that contributed to this query
			Kill $$$DeepSeeResultsGLVN($$$DeepSeeIndex(..%GetCubeName()),..%QueryKey,"params")
			Merge $$$DeepSeeResultsGLVN($$$DeepSeeIndex(..%GetCubeName()),..%QueryKey,"params") = pParms
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	
	// DTB065: If query execution is complete at this stage, run the audit code on this query
	If (..%GetStatus()= 100) {
		Do ..%RunQueryAuditCode()  	
	}
	
	Quit tSC
}

/// Materialize the initial (pre-null-filtered) axes for this ResultSet.
Method %ExecuteAxes() As %Status
{
	Set tSC = $$$OK
	Try {
		If '$IsObject(..%Query) {
			Set tSC = $$$ERROR($$$GeneralError,"Result set not prepared")
			Quit
		}
		Set tSC = ..%Query.%ExecuteAxes()
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Calculate the contents of the result cells for this Result Set.
Method %ExecuteCells() As %Status
{
	Set tSC = $$$OK
	Try {
		If '$IsObject(..%Query) {
			Set tSC = $$$ERROR($$$GeneralError,"%ExecuteCells: Result set not prepared")
			Quit
		}
		Write:..%Trace "Execute Cells: ",!
		Set tSC = ..%Query.%ExecuteCells(..%Trace)
		// + WAL071 -- release reserved axes before quitting so others can evaluate the query 
		//             even if there was an error
		If (..%Query.parentQueryKey="") {
			Set tCubeIndex = $$$DeepSeeIndex(..%Query.cube)
			Set tQueryKey = ..%Query.%QueryKey
			Set tSC = ##class(%DeepSee.Query.query).%ReleaseReservedAxes(tCubeIndex,tQueryKey)		// DTB168 - Use API
		}
		// - WAL071
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}	
	Quit tSC
}

/// For a DRILLTHROUGH query, find the set of source ids that make up
/// the *first* cell in the results and compute the SQL statement needed
/// to fetch the request fields from the source table (either as 
/// specified in the query's RETURN clause or the default listing for the cube).
Method %ExecuteListing(pStoreFactBits As %Boolean = 0) As %Status [ Internal ]
{
	Set tSC = $$$OK
	// JMD1390
	Set tLock = 0
	Try {
		$$$dsSetLogging		// DTB981
		
		Set tMaxRows = ..%Query.%MaxListingRows
		Set tAxisCount = ..%GetAxisCount()
		Set tCube = $$$UPPER(..%Cube)
		Set tCubeIndex = ..%CubeKey
		Set tQueryKey = ..%QueryKey
		Set tSlicerQueryKey = ..%QueryKey  // WAL107
		Set tListingTable = ""
					
		// + WAL107 -- if this is a plugin, write the listing out to a different
		//             listing table. This way, if multiple plugin cells require the
		//             same listing we don't have to worry about locking and concurrency,
		//             we just look at the appropriate listing table
		If (..%IsPlugIn) {
			Set tQueryKey = tQueryKey_"PlugIn"_$I(^DeepSee.PlugInNonce)   
			Set ..%PlugInListingKey = tQueryKey		
		}
		// - WAL107
		
		// + WAL170
		Set tListingPlugInName = ..%PlugInContextName
		Set tListingPlugInProp = ..%PlugInContextProp
		Set tListingPlugInClass = ##class(%DeepSee.Utils).%GetKPIClass(tListingPlugInName)
		Set ..%PlugInContextName = ""
		Set ..%PlugInContextProp = ""
		// - WAL170

		// JMD1397 check for listing on compound cube
		// in this case, we have to execute multiple listings and UNION the results
		If (..%Query.%isCompound) {
			Set ..listingRows = 0
			Set tSQL = ""
			For n = 1:1:..%Query.compoundDrillthroughs.Count() {
				Set tMDX = ..%Query.compoundDrillthroughs.GetAt(n)

				// execute this drillthrough and get its listing SQL
				// pivot variables should already be resolved
				Set tSubQRS = ##class(%DeepSee.ResultSet).%New()
				Set tSC = ..%SetSubqueryResultset(tSubQRS)		// DTB768 - Preserve the subquery object until the master resultset is closed
				If $$$ISERR(tSC) Quit
				
				Set tSC = tSubQRS.%PrepareMDX(tMDX)
				If $$$ISERR(tSC) Quit
				
				// + WAL208 -- pass the listing selection from the compound cube
				//             down to each constituent cube
				// DP-406786 - Set listing following the %PrepareMDX
				If (..listing'="") Set tSC = tSubQRS.%SetListing(..listing)
				If $$$ISERR(tSC) Quit
				// - WAL208

				Set tSC = tSubQRS.%Execute()
				If $$$ISERR(tSC) Quit
				If (tSubQRS.%ListingSQL'="") {
					Set tSQL = tSQL _ $S(tSQL="":"",1:$C(13,10)_"UNION ALL"_$C(13,10)) _ tSubQRS.%ListingSQL
					Set ..listingRows = ..listingRows + tSubQRS.listingRows
				}
			}
			Set ..%ListingSQL = tSQL

			// prepare union listing query
			Set tStatement = ##class(%SQL.Statement).%New(,"DEFAULT_SCHEMA")
			Set tStatement.%SelectMode = 2		// DTB418 - Default to display mode

			Set tSC = tStatement.%Prepare(..%ListingSQL)
			If $$$ISERR(tSC) {
				// log this error
			    Set tMsg = "Error in Listing query:"
			    Set tMsg = tMsg _ $C(13,10,9)_ ..%ListingSQL
			    Set tMsg = tMsg _ $C(13,10,9)_ $System.Status.GetErrorText(tSC)
			    Do ##class(%DeepSee.Utils).%WriteToLog("Listing",tMsg)
				Quit
			}
			Set ..%ListingResult = tStatement.%Execute()
			Quit
		}

		// this works as follows:
		// first we get the set of bits that describe the selected facts
		// then we get the source id for each fact and write it to 
		// the listing global
		// the listing global is mapped to a ListingTable (one per cube)
		// we then JOIN the sourceTable against ListingTable (using SQL with a subquery)
		// to get the listing rows.

		// JMD985: determine which facts are from list levels
		Set tFactCount = 0
		Set fn = $O($$$DeepSeeMetaGLVN("cubes",tCube,"fact#",""),1,tFactName)
		While (fn'="") {
			Set tFactCount = tFactCount+1
			If (tFactName'="") {
				Set tList = +$G($$$DeepSeeMetaGLVN("cubes",tCube,"fact","prop",tFactName,"list"))
				Set:tList tFactIsList(fn)=1
			}
			Set fn = $O($$$DeepSeeMetaGLVN("cubes",tCube,"fact#",fn),1,tFactName)
		}

		// JMD1390 block concurrent build of same listing
		Lock +$$$DeepSeeListingGLVN(tCubeIndex,tQueryKey):10
		If ('$Test) {
			Set tSC = $$$ERROR($$$GeneralError,"Unable to get lock to create listing")
			Quit
		}
		Set tLock = 1

		// Kill prior listing, if any
		Kill $$$DeepSeeListingGLVN(tCubeIndex,tQueryKey)
		Kill $$$DeepSeeListingBitGLVN(tCubeIndex,tQueryKey)

		Set tSourceType = $G($$$DeepSeeMetaGLVN("cubes",tCube,"sourceType"))
		Set tSourceClass = $G($$$DeepSeeMetaGLVN("cubes",tCube,"sourceClass"))
		If (tSourceClass="") {
			Set tSC = $$$ERROR($$$GeneralError,"%ExecuteListing: cube has no source class: " _ tCube)
			Quit
		}

		Set tCubeClass = $G($$$DeepSeeMetaGLVN("cubes",tCube))
		If ('$zobjclassmethod(tCubeClass,"%CanDrillThrough")) {
			If (..%Query.%listingSource '= "facts") {
				// JMD906: allow DRILLFACTS in this case
				Set tSC = $$$ERROR($$$GeneralError,"%ExecuteListing: this cube does not support drill through: " _ tCube)
				Quit
			}
		}

		Set tFactClass = ##class(%DeepSee.Utils).%GetCubeFactClass(tCube, .tSC)
		If $$$ISERR(tSC) Quit

		Set tSourceTable = ""
		If (..%Query.%listingSource = "facts") {
			Set tSourceTable = ##class(%DeepSee.Utils).%GetSQLTableName(tFactClass)
		}
		Else {
			If (tSourceType = "persistent") {
				Set tSourceTable = ##class(%DeepSee.Utils).%GetSQLTableName(tSourceClass)
				If (tSourceTable="") {
					Set tSC = $$$ERROR($$$GeneralError,"%ExecuteListing: cube has no source table: " _ tCube)
					Quit
				}
			}
		}

		// + WAL107 -- tSlicerQueryKey is the original query key used to get listing context
		//             if we are in this listing as the result of a plugin, tQueryKey may be
		//             different from tSlicerQueryKey
		// JMD955: if the slicer filters out everything, then return no values
		Set tNoRecords = 0

		Set tSlicer = $G($$$DeepSeeResultsGLVN(tCubeIndex,tSlicerQueryKey,"slicer")) // WAL107

		// see if slicer has any actual restrictions in it
		If (tSlicer'="") {
			// Get slicer key
			Set tSlicerKey = $G($$$DeepSeeResultsGLVN(tCubeIndex,tSlicerQueryKey,"axis",0)) // WAL107
			If (tSlicerKey'="") {
				Do ##class(%DeepSee.Query.Engine).%GetBranchesForSlicer(tCube, tSlicerKey, .tBranch,,.tReferencedFacts)
				If ('$D(tBranch)) {
					Set tSlicer = ""
					// JMD955: Return no records;
					If $D(tReferencedFacts) {
						Set tNoRecords = 1
					}
				}
				Else {
					// DTB717 - Check for special dimensions in the referenced facts array.
					// These will have negative fact numbers.
					If $D(tReferencedFacts(-1)) {
						// DTB717 - An %SQLRESTRICT is used, find its key in the slicer's tBranch
						Set tSqlRestrict=""
						Set tOrBranch = $O(tBranch(""))
						While (tOrBranch'="") {
							Set tAndBranch = $O(tBranch(tOrBranch,""),1,tBranchMember)
							While (tAndBranch'="") {
								If ($LG(tBranchMember,1)=-1) {
									// DTB717 - There should be only one. Break out of the loop as
									// soon as it is found.
									Set tSqlRestrict = $LG(tBranchMember,2)
									Quit
								}
								Set tAndBranch = $O(tBranch(tOrBranch,tAndBranch),1,tBranchMember)
							}
							Quit:(tSqlRestrict'="")
							Set tOrBranch = $O(tBranch(tOrBranch))
						}
					} 
				}
			}
		}
		// - WAL107

		// compute "window" from page and page size
		// JMD1318: for first page, get everything-- could be a group by query
		If (..listingPage=1) {
			Set tStartRow = 1
			Set tEndRow = 100000000
			Set tFirstPage = 1
		}
		Else {
			Set tStartRow = ((..listingPage-1) * ..listingPageSize) + 1
			Set tEndRow = tStartRow + ..listingPageSize - 1
			Set tFirstPage = 0
		}

		// AxisCount=0 is a special case: SELECT FROM CUBE
		Set tReturnAll = (tAxisCount = 0)||tNoRecords

		If (('tReturnAll)||(tSlicer'="")) {
			// convert to listing table
			Set tListingClass = $P(tFactClass,".",1,$L(tFactClass,".")-1)_".Listing"
			Set tListingTable = ##class(%DeepSee.Utils).%GetSQLTableName(tListingClass)
			If (tListingTable="") {
				Set tSC = $$$ERROR($$$GeneralError,"%ExecuteListing: cube has no listing table: " _ tCube)
				Quit
			}

			// number of fact properties in cube
			Set tFactCount = +$G($$$DeepSeeMetaGLVN("cubes",tCube,"factCount"))
			// JMD1453
			If (tFactCount="") {
				Set tSC = $$$ERROR($$$GeneralError,"Cube must be recompiled")
				Quit
			}

			// find set of relations for this cube (if any)
			// these will be processed using a join index
			Set r = $O($$$DeepSeeMetaGLVN("cubes",tCube,"rel#",""))
			While (r'="") {
				Set tRelation(r) = ""
				Set r = $O($$$DeepSeeMetaGLVN("cubes",tCube,"rel#",r))
			}

			// get "spec" for set of facts (from cell 1,1)
			// n.b., drillthrough only looks at top left cell
			Set tSpec = $Case(tAxisCount,
				0:..%GetValue(),
				1:..%GetOrdinalValue(1),
				:..%GetOrdinalValue(1,1))

			// JMD836: keys in spec are not in canonic form (e.g. "2|3|4&2")
			// fix them here
			// JMD955: test for bad list (e.g., "No Results")
			If '$ListValid(tSpec) {
				Set tSpec = ""
			}

			For p=1:1:$LL(tSpec) {
				// JMD985: do not canonize list facts
				// remember if there are ORs in the slicer, then tSpec is concatenated
				// for each branch!
				If '$D(tFactIsList((p#(tFactCount+1))-1)) {
					Set xp = $LG(tSpec,p)
					Set:(xp'="")&&($E(xp)'="!") $List(tSpec,p) = ##class(%DeepSee.Query.Engine2).%CanonizeAddr(xp)
				}
			}

			// break spec into pieces (each with one complete set of fact keys)
			// if there are multiple pieces, they are OR'd together
			Set tPieceCount = $LL(tSpec) / (tFactCount+1)
			For p=1:1:tPieceCount {
				Set x = (p-1)*(tFactCount+1)

				// JMD858 Test for empty spec; this means return all rows; (SELECT ALLMBR ON 0...)
				Set tSpec2 = $List(tSpec,x+1,x+tFactCount+1)
				Set tSpecNotEmpty = 0
				For px=1:1:$LL(tSpec2) {
					If ($LG(tSpec2,px)'="") {
						Set tSpecNotEmpty = 1
						Quit
					}
				}
				If (tSpecNotEmpty) {
					Set tSpecPart(p) = tSpec2
				}
				ElseIf (tSlicer'="") {
					// skip this spec
					Set tSpecPart(p) = ""
				}
				Else {
					Set tReturnAll = 1
					Quit
				}
			}

			If (('tReturnAll)||(tSlicer'="")) {
				Set tUseFacts = (..%Query.%listingSource = "facts")

				// loop over fact extent and apply filtering
				Set tCount = 0
				Set tChunk = $O($$$DeepSeeIndexGLVN(tCubeIndex,"$Fact",""),1,data)

				// JMD1318: ignore tMaxRows when fetching bits for first page
				// this makes it possible to run GROUP BY and other queries
				While ((tChunk '= "")&&(tFirstPage||pStoreFactBits||(tCount<tMaxRows))) {
					// DTB717 - At this point, apply the %SQLRESTRICT to the current chunk of data. 
					// This assumes that the %SQLRESTRICT is strictly ANDed with other licers in the 
					// original query.
					If ($G(tSqlRestrict)'="") {
						Set tSqlRestrictChunk = $G($$$DeepSeeIndexGLVN(tCubeIndex,-1,tSqlRestrict,tChunk))
						$$$dsBitAandBIntoA(data,tSqlRestrictChunk)		// DTB981
					}
					
					// Check the mask cache for a slicer index for this slicer key.
					If (tAxisCount=0) && ($G(tSlicerKey)'="") && $D($$$DeepSeeMaskGLVN(tCubeIndex,"slicer",$$$DeepSeeChunkToCacheSlot(tCubeIndex,tChunk),tSlicerKey)) {
						// DP-429168 - The work of calculating the slicer is already done, use the cached result.
						$$$dsBitAandB(data,$$$DeepSeeMaskGLVN(tCubeIndex,"slicer",$$$DeepSeeChunkToCacheSlot(tCubeIndex,tChunk),tSlicerKey,tChunk),tFullMask)
					}
					Else {
						// DP-429168 - There wasn't a pre-processed slicer mask available, or there is a more complex context.
						// Compute the mask from the complete collection of tSPecPart components.
						$$$dsBitFind(data,1,tBit)		// DTB981
						If (tBit>0) {
							Kill tFullMask
							For p=1:1:tPieceCount {
								// JMD858: skip missing spec
								If (tSpecPart(p)="") {
									// set spec to extent mask
									Set tFullMask = data
								}
								Else {
									Set tMask = data
									For f = 1:1:tFactCount {
										Set k = $LG(tSpecPart(p),f+1)
										If (k'="") {
											If ($D(tRelation(f))&&($E(k)="@")) { // this is a relation
												Set k=##class(%DeepSee.Query.Engine2).%CanonizeRelationKey(k) // JSL4407
												// JMD1017
												Set khash = $S($L(k)<100:k,1:$ZCRC(k,7))
												If '$D(tMask) {
													Set tMask = $G($$$DeepSeeJoinGLVN(tCubeIndex,f,khash,tChunk))
												}
												Else {
													$$$dsBitAandBIntoA(tMask,$$$DeepSeeJoinGLVN(tCubeIndex,f,khash,tChunk))		// DTB981
												}
											}
											Else {
												// JMD1160: loop over & first
												For j = 1:1:$L(k,"&") {
													Set k2 = $P(k,"&",j)
													If (k2'="") {
														Kill tTest
														If (k2["|") {
															// OR
															For j2 = 1:1:$L(k2,"|") {
																Set k3 = $P(k2,"|",j2)
																If (k3'="") {
																	Set tTest(j2) = tMask
																	If ($E(k3)="!") {
																		// strip off marker and negate index
																		Set k3 = $E(k3,2,*)
																		$$$dsBitAandNotBIntoA(tTest(j2),$$$DeepSeeIndexGLVN(tCubeIndex,f,k3,tChunk))		// DTB981
																	}
																	Else {
																		$$$dsBitAandBIntoA(tTest(j2),$$$DeepSeeIndexGLVN(tCubeIndex,f,k3,tChunk))		// DTB981
																	}
																}
															}
															// fold branches
															Set tMask = ""
															Set jx = $O(tTest(""))
															If (jx'="") {
																Set tMask = tTest(jx)
																Set jx = $O(tTest(jx))
															}
															While (jx'="") {
																$$$dsBitAorBIntoA(tMask,tTest(jx))		// DTB981
																Set jx = $O(tTest(jx))
															}
														}
														Else {
															// test for NOT (!)
															If ($E(k2)="!") {
																// strip off marker and negate index
																Set k2 = $E(k2,2,*)
																$$$dsBitAandNotBIntoA(tMask,$$$DeepSeeIndexGLVN(tCubeIndex,f,k2,tChunk))		// DTB981
															}
															Else {
																$$$dsBitAandBIntoA(tMask,$$$DeepSeeIndexGLVN(tCubeIndex,f,k2,tChunk))		// DTB981
															}
														}
													}
												}
											}
										}
										$$$dsBitFind(tMask,1,tHasBit)		// DTB981
										Set:$D(tMask)&(tHasBit=0) tMask=""
									} // f

									// OR pieces together
									If ('$D(tFullMask)&&$D(tMask)) {
										Set tFullMask = $G(tMask)
									}
									ElseIf ($D(tFullMask)&&$D(tMask)) {
										$$$dsBitAorBIntoA(tFullMask,tMask)		// DTB981
									}
								} // for p
							} // spec'=""
						}
					}

					// mask against extent
					If $D(tFullMask) {
						// JMD858: make tFullMask the lvar
						// (already masked)
						// Set tFullMask = $BitLogic(data&tFullMask)
					
						// BDB243: store bitset output
						Set:pStoreFactBits $$$DeepSeeListingBitGLVN(tCubeIndex, tQueryKey, tChunk) = tFullMask
					}

					// emit ids
					Set tOffset = (tChunk-1)*64000
					$$$dsBitFind(tFullMask,1,tBit)		// DTB981
					While ((tBit > 0)&&(tFirstPage||(tCount<tMaxRows))) {
						Set tFactId = tBit+tOffset-1
						If (tUseFacts) {
							// JMD906: no need to convert ids
							Set tCount = tCount + 1
							If ((tCount>=tStartRow)&&(tCount<=tEndRow)) {
								Set $$$DeepSeeListingGLVN(tCubeIndex,tQueryKey,tFactId) = ""
							}
						}
						Else {
							// convert into sourceId via %sourceId reverse index
							Set tSourceId =  $G($$$DeepSeeIndexGLVN(tCubeIndex,"%sourceIdReverse",tFactId))

							If (tSourceId'="") {
								Set tCount = tCount + 1
								If ((tCount>=tStartRow)&&(tCount<=tEndRow)) {
									// insert directly into listing table the old-fashioned way!
									Set $$$DeepSeeListingGLVN(tCubeIndex,tQueryKey,tSourceId) = ""
								}
							}
						}
						$$$dsBitFindNext(tFullMask,1,tBit+1,tBit)		// DTB981
					}
					Set tChunk = $O($$$DeepSeeIndexGLVN(tCubeIndex,"$Fact",tChunk),1,data)
				} // next chunk
			} // return All
		} // axis count

		// BDB251: make sure $$$DeepSeeListingBitGLVN is populated if tReturnAll=1 && tSlicer=""
		If (tReturnAll && (tSlicer="") && pStoreFactBits && 'tNoRecords) {
			// this is not particularly fast for large datasets, but the bitstring is
			// at least 100% correct and the code only gets executed if pStoreFactBits
			// was explicitly set to 1 by the invoking code
			set tFactId="", tPrevChunk=0, tBits=""
			for {
				set tFactId = $order($$$DeepSeeIndexGLVN(tCubeIndex,"%sourceIdReverse",tFactId))
				quit:tFactId=""
				
				set tChunk = (tFactId\64000)+1, tBitPos = (tFactId#64000)+1
				if (tChunk '= tPrevChunk) {
					set:tPrevChunk $$$DeepSeeListingBitGLVN(tCubeIndex, tQueryKey, tPrevChunk) = tBits, tBits=""
					set tPrevChunk = tChunk
				}
				$$$dsBitSet(tBits,tBitPos,1)		// DTB981
			}
			set:tPrevChunk $$$DeepSeeListingBitGLVN(tCubeIndex, tQueryKey, tPrevChunk) = tBits
		}

		Set ..listingRows = $G(tCount,tMaxRows)
		Set:..listingRows>tMaxRows ..listingRows = tMaxRows		// JMD1318

		// ----------------------------------------------
		// now create query

		// tListingSourceClass is set if the cube defines a data connector for its listing
		Set tListingSourceClass = ""
		Set tCustomSQL = ""
		Set tSelectList = ""
		Set ..listingFormatList = ""

		// figure out what SQL or connector to use
		// $LISTING means use default in place
		Set ..%ListingFields = ""
		Set tSourceRowId = "%ID"

		// JMD1061 Use %GetDefaultListing method
		Set tListing = ..listing
		If (tListing="") {
			Set tListing = $classmethod(tCubeClass,"%GetDefaultListing")
		}
		
		If ((..%Query.%returnList '= "")&&($ZSTRIP($$$UPPER(..%Query.%returnList),"<>W")'="$LISTING")) {
			// explicit listing in query
			Set tSelectList = ..%Query.%returnList
		}
		ElseIf (..%Query.%listingSource = "facts") {
			// query against fact table (not source table)
			Set tSelectList = "%ID"
		}
		ElseIf ((tListing="$$$CUSTOM")&&(..%Query.%returnList="")) {
			// DTB505 - Communicate the fact that the Custom Listing has no fields defined
			Set tSC = $$$ERROR($$$GeneralError,"A Custom Listing must define at least one listing field")
			Quit
		}
		ElseIf (tListing'="") {
			// use named listing in cube
			// test if user holds resource for this listing
			
			// DTB082 - Determine whether this listing definition exists, and if so where the metatdata is stored
			// DTB130 - look for listing groups according to the generic cube name. Standard listings are stored in the 
			// cube definition and can be version dependent--continue looking for those according to the version name
			//   listings in the versioned cube name if it exists.
			Set tGenericCube = ##class(%DeepSee.CubeVersion.Utils).%GetGenericCubeName(tCube)
			If $D($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing)) {
				Set tListingExists = 1
				Set tListingMeta="cube"
				Set tResource = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"resource"))
			} ElseIf $D($$$DeepSeeListingGroupGLVN("cubes",tGenericCube,"listing",tListing)){								// DTB130
				Set tListingExists = 1
				Set tListingMeta="group"
				Set tResource = $G($$$DeepSeeListingGroupGLVN("cubes",tGenericCube,"listing",tListing,"resource"))			// DTB130
			} Else {
				// Non-existent listing didn't trigger the error message
				Set tListingExists = 0
			}
			
			If tListingExists&&((tResource="")||($System.Security.Check(tResource,"USE"))) {
				If tListingMeta="cube" {
					Set tSelectList = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"fieldList"),tSourceRowId)
					Set tCustomSQL = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"sql"))
					Set tListingSourceClass = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"sourceClass"))
					Set tSelectMode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"selectMode"))		// DP-414835
					Set ..listingFormatList = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",tListing,"formatList"))
				} Else {
					// DTB082 - Listing is defined in a listing group
					// DTB130 - Switch to generic cube name
					Set tSelectList = $G($$$DeepSeeListingGroupGLVN("cubes",tGenericCube,"listing",tListing,"fieldList"),tSourceRowId)
					Set tCustomSQL = $G($$$DeepSeeListingGroupGLVN("cubes",tGenericCube,"listing",tListing,"sql"))
					Set tListingSourceClass = $G($$$DeepSeeListingGroupGLVN("cubes",tGenericCube,"listing",tListing,"sourceClass"))
					Set tSelectMode = $G($$$DeepSeeListingGroupGLVN("cubes",tGenericCube,"listing",tListing,"selectMode"))		// DP-414835
					Set ..listingFormatList = $G($$$DeepSeeListingGroupGLVN("cubes",tGenericCube,"listing",tListing,"formatList"))
				}

			}
			Else {
				Set tSC = $$$ERROR($$$GeneralError,"Listing does not exist or you do not hold USE permission for it")
				Quit
			}
		}
		Else {
			// get default for cube
			Set tResource = $G($$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingResource"))
			If ((tResource="")||($System.Security.Check(tResource,"USE"))) {
				Set tSelectList = $G($$$DeepSeeMetaGLVN("cubes",tCube,"defaultListing"),tSourceRowId)
				Set tCustomSQL = $G($$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingSQL"))
				Set tListingSourceClass = $G($$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingSourceClass"))
				Set tSelectMode = $G($$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingSelectMode"))		// DP-416501
				Set ..listingFormatList = $G($$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingFormat"))
			}
			Else {
				Set tSC = $$$ERROR($$$GeneralError,"Listing does not exist or you do not hold USE permission for it")
				Quit
			}
		}

		// if true, restrict listing using an IN clause otherwise use a local subquery
		Set tUseINList = 0

		// use primary data connector for listing if none specified
		If (tListingSourceClass="") {
			Set tSourceType = $G($$$DeepSeeMetaGLVN("cubes",tCube,"sourceType"))
			If (tSourceType="dataconnector") {
				Set tListingSourceClass = $G($$$DeepSeeMetaGLVN("cubes",tCube,"sourceClass"))
			}
		}

		If (tListingSourceClass '= "") {
			// data connector
			Set tSupportsIDs=($$$defMemberKeyGet(tListingSourceClass,$$$cCLASSparameter,"SUPPORTSIDLIST",$$$cPARAMdefault)'="")
			If ('tSupportsIDs) {
				Set tSC = $$$ERROR($$$GeneralError,"Data Connector does not support listings")
				Quit
			}

			Set ..%ListingSQL = "{" _ tListingSourceClass _ "}"
			// PFS036 - Populate ..%ListingFields for Data Connector
			If (tSelectList'="") {
				For p2=1:1:$L(tSelectList,",") {
					Set tFld = $ZSTRIP($P(tSelectList,",",p2),"<>W")
					Set:tFld'="" ..%ListingFields = ..%ListingFields_$LB(tFld)
				}
			}
		}
		ElseIf (tCustomSQL = "") {
			// DTB576 - Check the source to determine if the table actually being queried is external
			If (..%Query.%listingSource = "facts") {
				Set tExternalTable=($$$defMemberKeyGet(tFactClass,$$$cCLASSparameter,"CONNECTION",$$$cPARAMdefault)'="")
			}
			Else {
				Set tExternalTable=($$$defMemberKeyGet(tSourceClass,$$$cCLASSparameter,"CONNECTION",$$$cPARAMdefault)'="")
			}
			If (tExternalTable) {
				Set tUseINList = 1
				Set tMaxRows = 1000
				// there is a hard limit on external listings
				// to avoid xDBC query problems
			}
			// create SQL query
			// add names to the select list
			// add qualifier to names in select list
			// unless name is already qualified
			Set tSELECT = ""
			
			// DTB649 - Use available parser
			Set tSC = ##class(%DeepSee.Utils).%ParseSQLFieldList(tSelectList,,.tFieldArray)
			If $$$ISERR(tSC) Quit
			
			Set tFieldNo = $O(tFieldArray(""),1,tFieldData)
			While (tFieldNo'="") {
				Set f = $ZSTRIP($ListToString($LG(tFieldData,1)," "),"<>W")		// DTB814 - Return format changed
				Set:f'="" tSELECT = tSELECT _ $S(tSELECT="":"",1:",") _ $S(($E(f,1)="("):f,$IsValidNum(+f):f,($$$UPPER(f))["SOURCE.":f,1:"source."_f)
				
				Set tFieldNo = $O(tFieldArray(tFieldNo),1,tFieldData)
			}

			Set tORDER = ""
			If (..%Query.%returnList '= "") {
				Set tOrderList = ..%Query.%orderList
			}
			ElseIf (..%Query.%listingSource = "facts") {
				Set tOrderList = ..%Query.%orderList
			}
			ElseIf (..listing'="") {
				// use named listing in cube
				If tListingMeta="cube" {
					Set tOrderList = $G($$$DeepSeeMetaGLVN("cubes",tCube,"listing",..listing,"orderBy"))
				} Else {
					// DTB082 - a listing group defines the ORDER BY clause
					Set tOrderList = $G($$$DeepSeeListingGroupGLVN("cubes",tCube,"listing",..listing,"orderBy"))
				}

			}
			Else {
				Set tOrderList = $G($$$DeepSeeMetaGLVN("cubes",tCube,"defaultListingOrder"))
			}

			// add names to order list
			// qualify names if needed
			Set tORDER = ""
			For n=1:1:$L(tOrderList,",") {
				Set f = $ZSTRIP($P(tOrderList,",",n),"<>W")
				Set:f'="" tORDER = tORDER _ $S(tORDER="":"",1:",") _ $S(($E(f,1)="("):f,$IsValidNum(+f):f,($$$UPPER(f))["SOURCE.":f,1:"source."_f)
			}
			Set:tORDER'="" tORDER = " ORDER BY " _ tORDER

			Set tWHERE = ""
			Set tFROM = tSourceTable_" source"
			If (('tReturnAll)||(tSlicer'="")) {
				If (tUseINList) {
					Set tIDCount = 0
					Set tDone = 0

					Set tINLIST = ""
					Set k = $O($$$DeepSeeListingGLVN(tCubeIndex,tQueryKey,""))
					While (k'="") {
						Set tIDCount = tIDCount + 1
						Set tINLIST = tINLIST _ $S(tINLIST="":"",1:",") _ "("_$Replace($$$quote(k),"""","'")_")"
						If (tIDCount>=tMaxRows) {
							Quit
						}
						Set k = $O($$$DeepSeeListingGLVN(tCubeIndex,tQueryKey,k))
					}
					If (tINLIST'="") {
						Set tWHERE = " WHERE source."_tSourceRowId_" IN ("_tINLIST_") "
					}
					Else {
						// no records
						Set tWHERE = " WHERE 1=0"
					}
				}
				Else {
					Set tWHERE = " WHERE source."_tSourceRowId_" IN (SELECT _DSsourceId FROM " _ tListingTable _ " WHERE _DSqueryKey = '"_tQueryKey_"')"
				}
			}
			// + WAL170 -- if the listing is run on a cell that gets it's value from a PlugIn, run the plugin so the user
			//             can filter the listing with the plugin logic if desired
			//             This is done by passing back a new "INLIST"
			If (tListingPlugInName'="") {
				Set tListingSource = $S((..%Query.%listingSource = "facts"):"FacTable",1:"SourceTable")
				Set tKPI = $classmethod(tListingPlugInClass,"%New")
				Set tListingFields = tKPI.%OnGetListingFields()
			
				Merge tOldDsContext = %dsCellContext
				Kill %dsCellContext
				Merge %dsCellContext = ..%PlugInFilters
				
				// + WAL262 -- pass along plugIn arguments from axis
				Merge %dsPlugInArguments = ..%PlugInArguments
				// - WAL262
								
				Set tListingPlugInIDList = ""
				Set tdsKPISync = +$G(%dsKPISync)
				Set %dsKPISync = 1
				Set tSC = tKPI.%OnLoadModel()
				If ('tdsKPISync) {
					Set %dsKPISync = tdsKPISync
				}
				Merge %dsCellContext = tOldDsContext
				
				Merge tListingPlugInIDList = tKPI.%data("IDLIST",tListingPlugInProp)
				If $$$ISERR(tSC) {
					Quit	
				}
				Set tINLIST = ""
				Set tIDCount = 0
				If ($O(tListingPlugInIDList(""))'="") {
					Set k = $O(tListingPlugInIDList(""))
					While (k'="") {
						Set tIDCount = tIDCount + 1
						Set tINLIST = tINLIST _ $S(tINLIST="":"",1:",") _ "("_$Replace($$$quote(k),"""","'")_")"
						If (tIDCount>=tMaxRows) {
							Quit
						}
						Set k = $O(tListingPlugInIDList(k))	
					}
				}
				Set tListingId = tSourceRowId
				If (..%Query.%listingSource = "facts") {
					Set tListingId = "%sourceId"	
				}
				Set:(tINLIST'="") tWHERE = " WHERE source."_tListingId_" IN ("_tINLIST_") "
			}
			// - WAL170
			
			If (tWHERE = "") {
				// special case of returning ALL source rows
				// see if there is a loadRestriction in play
				Set tOnProcessFact = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"onProcessFact"))
				Set tRestrict = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"buildRestriction"))
				
				If (..%Query.%listingSource '= "facts") {
					If tOnProcessFact'="" {
						// DTB119 - If %OnProcessFact was used, limit source IDs using the fact table
						Set tFactTable = ##class(%DeepSee.Utils).%GetSQLTableName(tFactClass)
						Set tWHERE = " WHERE source."_tSourceRowId_" IN (SELECT %sourceId FROM " _ tFactTable _ ")"
					}
					ElseIf (tRestrict'="") {
						// JMD942
						Set tWHERE = " WHERE " _ tRestrict
					}
				}
			}

			Set tTOP = ""
			If ('tExternalTable) {
				Set tTOP = $S(+tMaxRows:"TOP "_+tMaxRows_" ",1:"")
			}

			// JMD1127 replace $$$TEXT[ in SELECT
			//set tSC = ..RewriteQueryTag(.tSELECT, "$$$TEXT", "##class(%DeepSee.UserPortal.Utils).%ResolveText(""$$$""_$tr(""$$$1"",""""""'"")_""/""_$tr(""$$$2"",""""""'""))",,,, 1)
			//quit:$$$ISERR(tSC)

			// + DTB827 - Use the parser to identify headers with localization on
			Set tSC = ##class(%DeepSee.Utils).%ParseSQLFieldList(tSELECT,,.tSELECTArray,1)
			If $$$ISERR(tSC) Quit
			
			Set tSELECT = ""		// DTB827 - Reset for rebuild with localization 
			Set tFieldNo = $O(tSELECTArray(""),1,tFieldInfo)
			While (tFieldNo'="") {
				Set tSELECT = tSELECT _ $S((tSELECT)'="":", ",1:"") _ $ListToString($LG(tFieldInfo,2)," ")
				
				Set tFieldNo = $O(tSELECTArray(tFieldNo),1,tFieldInfo)
			}
			// - DTB827
			
			// BDB383: replace $$$PMML model references ($$$PMML[defClass,modelname,feature])
			set tSC = ..RewriteQueryTag(.tSELECT, "$$$PMML", "%DeepSee_PMML_Utils.DeepSee_RunModelForListing('"_tCube_"', source.%ID, '$$$1', '$$$2', '$$$3')", $lb(,,"predictedValue"))
			quit:$$$ISERR(tSC)

			// BDB168: support for iKnow summaries (BDB238: more than 1 per query)
			set tSC = ..RewriteQueryTag(.tSELECT, "$$$IKSUMMARY", "%iKnow_DeepSee.CubeUtils_GetSummary('"_tCube_"', '$$$1', source.%ID, $$$2)", $lb(,5), "$$$1 (summary)")
			quit:$$$ISERR(tSC)
			
			// BDB296: support for iKnow measure value popup
			set tSC = ..RewriteQueryTag(.tSELECT, "$$$IKLINK", "'''"_tCube_"'',''$$$1'','''||source.%ID||''''",, "$$$1", "___IKLINK")
			quit:$$$ISERR(tSC)
			
			// JMD955
			If (tNoRecords) {
				Set tWHERE = " WHERE (1=0) "
			}

			Set ..%ListingSQL = "SELECT "_tTOP_tSELECT_" FROM "_tFROM_tWHERE_tORDER
		}
		Else {
			// custom sql statement
			Set tWHERE = ""
			Set tFROM = tSourceTable_" source"

			If (('tReturnAll)||(tSlicer'="")) {
				If (tUseINList) {
					// in this case, impose a hard limit on the size of the IN list!
					Set tINLIST = ""

					Set k = $O($$$DeepSeeListingGLVN(tCubeIndex,tQueryKey,""))
					While (k'="") {
						Set tINLIST = tINLIST _ $S(tINLIST="":"",1:",") _ $Replace($$$quote(k),"""","'")
						Set k = $O($$$DeepSeeListingGLVN(tCubeIndex,tQueryKey,k))
					}

					If (tINLIST'="") {
						Set tWHERE = " source."_tSourceRowId_" IN ("_tINLIST_") "
					}
				}
				Else {
					Set tWHERE = " source."_tSourceRowId_" IN (SELECT _DSsourceId FROM " _ tListingTable _ " WHERE _DSqueryKey = '"_tQueryKey_"') "
				}
			}
			Else {
				// +DTB231 - special case of returning ALL source rows
				// see if there is a buildRestriction in play
				Set tOnProcessFact = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"onProcessFact"))
				Set tRestrict = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"buildRestriction"))
				
				If (..%Query.%listingSource '= "facts")&&(tCustomSQL["$$$SOURCE") {
					// This restriction is only needed if the listing is on the source table
					// AND the query is using the source table provided by the $$$SOURCE token
					If tOnProcessFact'="" {
						// If %OnProcessFact was used, limit source IDs using the fact table
						Set tFactTable = ##class(%DeepSee.Utils).%GetSQLTableName(tFactClass)
						Set tWHERE = " source."_tSourceRowId_" IN (SELECT %sourceId FROM " _ tFactTable _ ") "
					}
					ElseIf (tRestrict'="") {
						// JMD942
						Set tWHERE = tRestrict
					}
					Else {
						Set tWHERE = " (1=1) "
					}
				}
				Else {
					Set tWHERE = " (1=1) "
				}
				// -DTB231
			}

			Set tCustomSQL = $Replace(tCustomSQL,"$$$SOURCE",tFROM)
			Set tCustomSQL = $Replace(tCustomSQL,"$$$RESTRICT",tWHERE)
			
			// JMD1127: replace $$$TEXT[] parameters for listings
			//set tSC = ..RewriteQueryTag(.tCustomSQL, "$$$TEXT", "##class(%DeepSee.UserPortal.Utils).%ResolveText(""$$$""_$tr(""$$$1"",""""""'"")_""/""_$tr(""$$$2"",""""""'""))",,,, 1)
			//quit:$$$ISERR(tSC)
			Set tIKPos = $Find(tCustomSQL, "$$$TEXT[")
			While (tIKPos) {
				Set tParams = $E(tCustomSQL, tIKPos, $Find(tCustomSQL, "]", tIKPos)-2)
				
				If $Find(tParams,""",""") {
					// DTB657 - This has a domain
					Set tString = $Translate($Piece(tParams,",",1,*-1), """'")
					Set tDomain = $Translate($Piece(tParams,",",*), """'")
				}
				Else {
					// DTB657 - Header only with no declared domain
					Set tString = $Translate(tParams,"""'")
					Set tDomain = ""
				}
				
				If ($G(tDomain)'="") {
					Set tString = tString_"/"_tDomain
				}
				
				Set tString =  ##class(%DeepSee.UserPortal.Utils).%ResolveText("$$$"_tString)
				Set tCustomSQL = $E(tCustomSQL,1,tIKPos-9) _ tString _ $E(tCustomSQL,tIKPos+$length(tParams)+1,*)
				Set tIKPos = $Find(tCustomSQL, "$$$TEXT[")
			}
			
			// BDB383: replace $$$PMML model references ($$$PMML[defClass,modelname,feature])
			set tSC = ..RewriteQueryTag(.tCustomSQL, "$$$PMML", "%DeepSee_PMML_Utils.DeepSee_RunModelForListing('"_tCube_"', source.%ID, '$$$1', '$$$2', '$$$3')", $lb(,,"predictedValue"))
			quit:$$$ISERR(tSC)
			
			// BDB168: replacing parameters for iKnow Listings (BDB238: more than 1 per query)
			set tSC = ..RewriteQueryTag(.tCustomSQL, "$$$IKSUMMARY", "%iKnow_DeepSee.CubeUtils_GetSummary('"_tCube_"', '$$$1', source.%ID, $$$2)", $lb(,5), "$$$1 (summary)")
			quit:$$$ISERR(tSC)
			
			// BDB296: support for iKnow measure value popup
			set tSC = ..RewriteQueryTag(.tCustomSQL, "$$$IKLINK", "'''"_tCube_"'',''$$$1'','''||source.%ID||''''",, "$$$1", "___IKLINK")
			quit:$$$ISERR(tSC)
			
			// +DTB453
			Set tOrderList = ..%Query.%orderList
			If (tOrderList'="") {
				// DTB597 - Add "TOP Count" to the inner custom query if the subquery
				// already contains an ORDER BY
				Set tMaxCount = ##class(%DeepSee.Utils).%GetCubeFactCount(tCubeIndex)
				If (tMaxCount&&($TR($$$UPPER(tCustomSQL)," ","")["ORDERBY")) {
					Set tCustomSQL = "SELECT TOP " _ tMaxCount _ " " _ $P(tCustomSQL," ",2,*)
				}
				
				// DTB597 - Now use the custom listing as a subquery for the primary ORDER BY
				Set tCustomSQL = "SELECT * FROM (" _ tCustomSQL _ ") ORDER BY " _ tOrderList
			}
			// -DTB453
			
			Set ..%ListingSQL = tCustomSQL
		}

		// prepare result set
		If (tListingSourceClass '= "") {
			Set tConnector = $zobjclassmethod(tListingSourceClass,"%New")
			If ('tConnector.%IsA("%DeepSee.DataConnector")) {
				Set tSC = $$$ERROR($$$GeneralError,"Source class is not a DataConnector: " _ tListingSourceClass)
				Quit
			}

			// pass restriction information to connector
			If (tListingTable'="") {
				Set tSC = tConnector.%SetMode("idlist")
				If $$$ISERR(tSC) Quit

				Set tSC = tConnector.%SetIdList(tListingTable,tQueryKey,tCubeIndex)
				If $$$ISERR(tSC) Quit
			}

			// Run dataconnector in odbc-mode
			Set dcm = $ZU(115,5,1)

			Kill tParms
			Set ..%ListingResult = tConnector.%Execute(.tParms,.tSC)
			Set x = $ZU(115,5,dcm)
			If $$$ISERR(tSC) Quit
		}
		Else {
			// sql

			// invoke callback
			Set tCubeClass = $G($$$DeepSeeMetaGLVN("cubes",tCube))
			Set tSC = $zobjclassmethod(tCubeClass,"%OnExecuteListing",..%ListingSQL)
			If $$$ISERR(tSC) Quit

			// prepare listing query
			Set tStatement = ##class(%SQL.Statement).%New(,"DEFAULT_SCHEMA")
			Set tStatement.%SelectMode = $G(tSelectMode,2)		// DP-414835 - Use selectMode provided by the listing, default to display mode

			Set tSC = tStatement.%Prepare(..%ListingSQL)
			If $$$ISERR(tSC) {
				// log this error
			    Set tMsg = "Error in Listing query:"
			    Set tMsg = tMsg _ $C(13,10,9)_ ..%ListingSQL
			    Set tMsg = tMsg _ $C(13,10,9)_ $System.Status.GetErrorText(tSC)
			    Do ##class(%DeepSee.Utils).%WriteToLog("Listing",tMsg)
				Quit
			}
			Set ..%ListingResult = tStatement.%Execute()
		}
		Set $$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"plan",$I($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"plan"))) = $LB("listing",tCube,..%ListingSQL)
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	// JMD1390
	If (tLock) {
		Lock -$$$DeepSeeListingGLVN(tCubeIndex,tQueryKey)
	}

	Quit tSC
}

/// Replaces a "tag" in a listing query <var>pSQL</var> (fieldList or straight SQL), using the 
/// string in <var>pRewrite</var>. The tag (such as $$$IKSUMMARY) can have zero or more parameters
/// in square brackets, which will be used to replace $$$1, $$$2, etc markers in <var>pRewrite</var>,
/// defaulting to the corresponding positions in <var>pDefaultParams</var> if no value is supplied
/// with the tag. <var>pRewrite</var> is supposed to contain appropriate quotes, as surrounding
/// single and double quotes in the tag itself will be removed.
/// If <var>pDefaultAlias</var> is non-null, it will be appended as the column alias for the rewrite
/// expression. This alias can also contain $$$1, $$$2, etc markers.
/// If <var>pAliasPrefix</var> is set, it will be prepended to any existing (or default) alias.
/// If <var>pStatic</var>=1, the rewrite code is considered to be COS code and run once, with its
/// result then replacing the tag in the query.
ClassMethod RewriteQueryTag(ByRef pSQL As %String, pTagName As %String, pRewrite As %String, pDefaultParams As %List = "", pDefaultAlias As %String = "", pAliasPrefix As %String = "", pStatic As %Boolean = 0) As %Status [ Internal ]
{
	set tSC = $$$OK
	try {
		set tTagLength = $length(pTagName)
		set tParamCount = $length(pRewrite_" "_pDefaultAlias,"$$$")-1
		
		while 1 {
			// find the next occurrence of pTagName
			set tPos = $find(pSQL, pTagName)
			quit:'tPos
			set tSqlLength = $length(pSQL), tStartPos = tPos-tTagLength-1
			
			// locate closing "]" and parameter list
			kill tParams
			set tParams = 0
			if ($e(pSQL,tPos)="[") {
				set tQuotes = "", tLastParamStart = tPos+1
				while ($i(tPos)<=tSqlLength) {
					set tChar = $e(pSQL,tPos)
					
					if (tChar=tQuotes) {
						if $e(pSQL,tPos+1)=tQuotes {
							// double quote!
							set tPos = tPos+1
							continue
						} else {
							// end of a quoted string
							set tQuotes = ""
							continue
						}
					} elseif (tChar="""") || (tChar="'") {
						// start of a quoted string
						set tQuotes = tChar
						continue
					}
					
					// skip if we're in a quoted string
					continue:tQuotes'=""
					
					// parameter ends at "]" or ","
					if (tChar = "]") || (tChar=",") {
						
						// get rid of surrounding quotes, these should be taken care of by pRewrite
						set tParam = $zstrip($e(pSQL,tLastParamStart,tPos-1),"<>W")
						if ($e(tParam)="'") && ($e(tParam,*)="'") {
							set tParam = $e(tParam,2,*-1)
						} elseif ($e(tParam)="""") && ($e(tParam,*)="""") {
							set tParam = $e(tParam,2,*-1)
						}
						set tParams($i(tParams)) = tParam
						
						quit:(tChar="]")
						set tLastParamStart = tPos+1
					}
					
				}
				set tEndPos = tPos+1
			} else {
				set tEndPos = tPos
			}
			
			// alias processing
			if (pDefaultAlias'="") || (pAliasPrefix'="") {
				if ($e(pSQL,tPos)=",") {
					// no trailing space, parameters or alias
					set tAlias = ""
				} else {
					set tQuotes = "", tAliasStart = tPos+1
					while ($i(tPos)<=tSqlLength) {
						set tChar = $e(pSQL,tPos)
						
						if (tChar=tQuotes) {
							if $e(pSQL,tPos+1)=tQuotes {
								// double quote!
								set tPos = tPos+1
								continue
							} else {
								// end of a quoted string
								set tQuotes = ""
								continue
							}
						} elseif (tChar="""") {
							// start of a quoted string
							set tQuotes = tChar
							continue
						}
						
						// skip if we're in a quoted string
						continue:tQuotes'=""
						
						quit:tChar=","
						quit:$e(pSQL,tPos,tPos+4)="FROM "
					}
					set tAliasEnd = tPos-1
					
					set tAlias = $zstrip($e(pSQL, tAliasStart, tAliasEnd), "<>W")
					
					// get rid of "As" keyword
					set:$$$UPPER($e(tAlias,1,3))="AS " tAlias = $zstrip($e(tAlias,4,*), "<>W")
					
					// get rid of alias quotes. we'll restore them later if required
					set:($e(tAlias)="""")&&($e(tAlias,*)="""") tAlias = $zstrip($e(tAlias,2,*-1), "<>W")
					
					set tEndPos = tAliasEnd+1
				}
				
				if (tAlias="") {
					set tAlias = pDefaultAlias
				}
				
				if (pAliasPrefix'="") {
					set tAlias = pAliasPrefix_$s(tAlias="":"", 1:" "_tAlias)
				}
				
				set:$f(tAlias," ") tAlias = $$$QUOTE(tAlias)
				set:tAlias'="" tAlias = " As "_tAlias
			} else {
				set tAlias = ""
			}
			
			set tRewrite = pRewrite
			set:tParams>tParamCount tParamCount = tParams
			for i = 1:1:tParamCount {
				set tParam = $g(tParams(i),$lg($g(pDefaultParams),i))
				set tRewrite = $replace(tRewrite, "$$$"_i, tParam)
				set tAlias = $replace(tAlias, "$$$"_i, tParam)
			}
			
			if (pStatic) {
				xecute ("(tValue) { set tValue = "_tRewrite_" }", .tValue)
				set tRewrite = tValue
			}
			
			set pSQL = $e(pSQL,1,tStartPos) _ " "_tRewrite_tAlias_" " _ $e(pSQL,tEndPos,*)
		}
		
	} catch (ex) {
		set tSC = ex.AsStatus()
	}
	quit tSC
}

/// Perform the work of a CREATE or DROP statement.
Method %ExecuteSessionCommand() As %Status [ Internal, Private ]
{
	Set tSC = $$$OK
	Try {
		If (..%Query.queryType = "CREATE") {
			// apply definition
			If (..%Query.%target = "set") {
				Set tKey = ""
				Set tSet = ..%Query.namedSets.GetNext(.tKey)
				While (tKey '= "") {
					// add definition to session data
					If $IsObject($G($$$DeepSeeSession)) {
						Set tSessionId = $$$DeepSeeSession.%GetSessionId()
						Set tInfo = $LB(tSet.name,tSet.definition)
						Set $$$DeepSeeSessionGLVN(tSessionId,..%CubeKey,"namedSets",tKey) = tInfo
					}
					Set tSet = ..%Query.namedSets.GetNext(.tKey)
				}
			}
			ElseIf (..%Query.%target = "member") {
				Set tKey = ""
				Set tSet = ..%Query.calculatedMembers.GetNext(.tKey)
				While (tKey '= "") {
					// add definition to session data
					If $IsObject($G($$$DeepSeeSession)) {
						Set tSessionId = $$$DeepSeeSession.%GetSessionId()
						Set tInfo = $LB(tSet.parentDimension,tSet.originalName,tSet.definition)
						Set $$$DeepSeeSessionGLVN(tSessionId,..%CubeKey,"calcMbrs",tKey) = tInfo
					}
					Set tSet = ..%Query.calculatedMembers.GetNext(.tKey)
				}
			}
		}
		ElseIf (..%Query.queryType = "DROP") {
			If (..%Query.%target = "set") {
				Set tKey = ..%Query.%targetKey
				If (tKey '= "") {
					// remove definition from session data
					If $IsObject($G($$$DeepSeeSession)) {
						Set tSessionId = $$$DeepSeeSession.%GetSessionId()
						Kill $$$DeepSeeSessionGLVN(tSessionId,..%CubeKey,"namedSets",tKey)
					}
				}
			}
			ElseIf (..%Query.%target = "member") {
				Set tKey = ..%Query.%targetKey
				If (tKey '= "") {
					// remove definition from session data
					If $IsObject($G($$$DeepSeeSession)) {
						Set tSessionId = $$$DeepSeeSession.%GetSessionId()
						Kill $$$DeepSeeSessionGLVN(tSessionId,..%CubeKey,"calcMbrs",tKey)
					}
				}
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Return number of visible nodes within the given axis (1-based).
Method %GetAxisSize(pAxis As %Integer) As %Integer
{
	// DTB - Direct lookup to the appropriate cache copy
	Quit +$G(@..%ResultCacheLocation@(..%CubeKey,..%QueryKey,"leaf",pAxis))
}

/// Return the count of columns in results table.
Method %GetColumnCount() As %Integer
{
	// Method added by DTB281
	Quit $S(..%GetAxisSize(1):..%GetAxisSize(1),1:1)
}

/// Return the count of rows in results table.
Method %GetRowCount() As %Integer
{
	// Method added by DTB281
	Quit $S(..%GetAxisSize(2):..%GetAxisSize(2),1:1)
}

/// Return number of axes within the result set (not including the slicer).
/// Returns 0 if the query has not been prepared and had its
/// axes executed.<br/>
/// On return, <var>pInfo</var> will contain array of axis number (1-based)
/// to axis top node number.
Method %GetAxisCount(Output pInfo As %Integer) As %Integer
{
	Kill pInfo
	Set tCount = 0
	Set tCube = ..%CubeKey
	Set tKey = ..%QueryKey

	If ((tCube'="")&&(tKey'="")&&$D(@..%ResultCacheLocation@(tCube,tKey,"size"),size)) {
		For n = 1:1:$LL(size) {
			Set tInfo = $LG(size,n)
			Set tType = $LG(tInfo,1)
			If (tType = "axis") {
				Set tCount = tCount + 1
				Set pInfo(tCount) = $LG(tInfo,2)
			}
		}
	}
	
	Set ..%AxisCount = tCount
	Quit tCount
}

/// Return true if the current query has to be tested for cell format overrides.
Method %HasCellFormatOverride() As %Boolean
{
	// DTB - Check whether the local or common copy is being used
	Quit ''$D(@..%ResultCacheLocation@(..%CubeKey,..%QueryKey,"cmbrMap"))
}

/// Determine if the format for the given cell has been overridden (such as by
/// currentMember substitution) and return it.
/// <var>pCell...</var> contains the ordinal address of the cell.
Method %GetCellFormatOverride(pCell...) As %String
{
	Set tFormat = ""
	Set tAxisCount = ..%AxisCount
	If (tAxisCount="") {
		Set tAxisCount = ..%GetAxisCount()
	}
	Set tCube = ..%CubeKey
	Set tMissing = 0

	For a = 1:1:tAxisCount {
		// If no cell specified, use first cell along axis
		Set tCell = $S($G(pCell(a))'="":pCell(a),1:$O(@..%ResultCacheLocation@(tCube,..%QueryKey,"leaf",a,"")))

		If (tCell'="") {
			// find node number for cell
			Set tNode(a) = $G(@..%ResultCacheLocation@(tCube,..%QueryKey,"leaf",a,tCell))
		}

		If ((tCell="") || (tNode(a)="")) {
			Set tMissing = 1
			Quit
		}
	}

	If ('tMissing) {
		Set tFormat = $LG($G(@..%ResultCacheLocation@(tCube,..%QueryKey,"cmbrMap",tNode(1),tNode(2),0)),12)
	}
	Quit tFormat
}

/// Get the value of the cell specified by the ordinal cell numbers 
/// <var>pCell1</var>, <var>pCell2</var>...<br/>
/// A cell number is the ordinal number of a cell along its axis.<br/>
/// The column axis is axis number 1, the row axis is axis number 2 and so on.<br/>
/// If the result has more dimensions than are provided, or if values are omitted, then the
/// first cell along each additional dimension is used.
Method %GetOrdinalValue(pCell...) As %String
{
	Set tAxisCount = ..%AxisCount
	If (tAxisCount="") {
		Set tAxisCount = ..%GetAxisCount()
	}
	Set tCube = ..%CubeKey
	Set tValue = ""
	Set tMissing = 0

	For a = 1:1:tAxisCount {
		// If no cell specified, use first cell along axis
		Set tCell = $S($G(pCell(a))'="":pCell(a),1:$O(@..%ResultCacheLocation@(tCube,..%QueryKey,"leaf",a,"")))

		If (tCell'="") {
			// find node number for cell
			Set tNode(a) = $G(@..%ResultCacheLocation@(tCube,..%QueryKey,"leaf",a,tCell))
		}

		If ((tCell="") || (tNode(a)="")) {
			Set tMissing = 1
			Quit
		}
	}

	If ('tMissing) {
		Set tValue = $Case(tAxisCount,
			0:..%GetValue(),
			1:..%GetValue(tNode(1)),
			2:..%GetValue(tNode(1),tNode(2)),
			3:..%GetValue(tNode(1),tNode(2),tNode(3)),
			4:..%GetValue(tNode(1),tNode(2),tNode(3),tNode(4)),
			5:..%GetValue(tNode(1),tNode(2),tNode(3),tNode(4),tNode(5)),
			6:..%GetValue(tNode(1),tNode(2),tNode(3),tNode(4),tNode(5),tNode(6)),
			7:..%GetValue(tNode(1),tNode(2),tNode(3),tNode(4),tNode(5),tNode(6),tNode(7)),
			:"")
	}

	Quit tValue
}

/// Get the value of the cell specified by the node numbers 
/// <var>pNode1</var>, <var>pNode2</var>...
Method %GetValue(pNode...) As %String
{
	// count nodes
	Set tCount = 0
	Set n = $O(pNode(""))
	While (n'="") {
		Set tCount = tCount + 1
		Set n = $O(pNode(n))
	}
	Set tValue = $Case(tCount,
		0:$G(@..%ResultCacheLocation@(..%CubeKey,..%QueryKey,"data",0)),
		1:$G(@..%ResultCacheLocation@(..%CubeKey,..%QueryKey,"data",0,pNode(1))),
		2:$G(@..%ResultCacheLocation@(..%CubeKey,..%QueryKey,"data",0,pNode(1),pNode(2))),
		3:$G(@..%ResultCacheLocation@(..%CubeKey,..%QueryKey,"data",0,pNode(1),pNode(2),pNode(3))),
		4:$G(@..%ResultCacheLocation@(..%CubeKey,..%QueryKey,"data",0,pNode(1),pNode(2),pNode(3),pNode(4))),
		5:$G(@..%ResultCacheLocation@(..%CubeKey,..%QueryKey,"data",0,pNode(1),pNode(2),pNode(3),pNode(4),pNode(5))),
		6:$G(@..%ResultCacheLocation@(..%CubeKey,..%QueryKey,"data",0,pNode(1),pNode(2),pNode(3),pNode(4),pNode(5),pNode(6))),
		7:$G(@..%ResultCacheLocation@(..%CubeKey,..%QueryKey,"data",0,pNode(1),pNode(2),pNode(3),pNode(4),pNode(5),pNode(6),pNode(7))),
		:"")
	Quit tValue
}

/// Find the axis label(s) for the item with ordinal position
/// <var>pPosition</var> within axis <var>pAxis</var> (1 = cols, 2 = rows).<br/>
/// Returns, via <var>pLabel</var> an array of labels associated with the item
/// from the most specific to the most general.<br/>
/// The return value is the number of labels returned.<br/>
/// Also returns, by reference the format and solve order for the label (higher solve order
/// takes precedence over lower and is used to determine which axis should supply the format for
/// a cell).
/// <var>pClasses</var> an array of classes associated with the item
Method %GetOrdinalLabel(Output pLabel As %String, pAxis As %Integer, pPosition As %Integer, Output pFormat As %String, Output pSolveOrder As %Integer, Output pStyle As %String, Output pHeaderStyle As %String, Output pClasses As %String, Output pTimeFormat As %String) As %Integer
{
	Set tSC = $$$OK
	Kill pLabel
	Set pFormat = ""
	Set pStyle = ""
	Set pHeaderStyle = ""
	Set pSolveOrder = 0
	Set tLabelCount = 0

	Try {
		// DTB248 - Call API to collect relevant nodes for this label
		Set tSC = ..%GetOrdinalLabelNodes(pAxis,pPosition,.tNodes)
		If $$$ISERR(tSC) Quit
		
		// DTB248 - Go back through the labels last-to-first with new skip information
		Set tNodeNo=$O(tNodes(""),-1,tNode)
		While tNodeNo'="" {
			Set tType = $$$dsAxisNodeTypeGet(tNode)
			Set tLabel = $$$dsAxisNodeLabelGet(tNode)
			Set tSolveOrder = +$LG(tNode,15)
			//+ JSL4456
			Set tDimNo = +$$$dsAxisNodeDimGet(tNode)
			Set tHierNo = +$$$dsAxisNodeHierGet(tNode)
			Set tLevelNo = +$$$dsAxisNodeLevelGet(tNode)
			//- JSL4456

			// JMD909
			Set tFormat = $LG(tNode,12)

			// JMD1375 first format takes precedence
			Set:(tFormat'="")&&(pFormat="") pFormat = tFormat

			Set:tSolveOrder>0 pSolveOrder = tSolveOrder
			If (tLabel'="")||(tType="lit") {		// DTB761 - A literal null is a valid label
				Set tLabelCount = tLabelCount + 1
				Set pLabel(tLabelCount) = tLabel
				Set tClass=$LG($G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(..%GetCubeName()),"mbr#",tDimNo,tHierNo,tLevelNo)),6) // class is 6th position JSL4456
				Set pClasses(tLabelCount) = tClass // JSL4456
				Set pTimeFormat(tLabelCount) = $LG($G($$$DeepSeeMetaGLVN("cubes",$$$UPPER(..%GetCubeName()),"mbr#",tDimNo,tHierNo,tLevelNo)),14)
				Set tStyle = $LG(tNode,18)
				Set:tStyle'="" pStyle = tStyle
				Set tHeaderStyle = $LG(tNode,19)
				Set:tHeaderStyle'="" pHeaderStyle = tHeaderStyle
			}
			Set tNodeNo=$O(tNodes(tNodeNo),-1,tNode)
		}
	}
	Catch ex {
		// Swallow the error - no status is returned in this method
	}
	
	Quit tLabelCount
}

/// Examine the axis nodes(s) for the item with ordinal position <var>pPosition</var> within axis <var>pAxis</var>,
/// and build an array of nodes contributing to the label at this ordinal position along the axis. The collection of 
/// nodes is returned in the format<br>
/// <var>pNodeArray</var>(nodeNumber) = $LB(nodeInfo).
Method %GetOrdinalLabelNodes(pAxis As %Integer, pPosition As %Integer, ByRef pNodeArray) As %Status [ Internal ]
{
	// Method added by DTB248
	Set tSC = $$$OK
	Kill pNodeArray
	Set tSkipUntil = 0
	
	If ('$D(pAxis)||'$D(pPosition)) Quit
	Try {
		Set tCubeIndex = ..%CubeKey
		Set tAxisKey = $G(@..%ResultCacheLocation@(tCubeIndex,..%QueryKey,"axis",pAxis))
		
		// DP-409955 - Enable reading of the slicer nodes
		If ((pAxis=0)&&(tAxisKey'="")) {
			// This is the slicer so the results cache did not keep track of axis node positions
			// within the resultset. Since this axis should be a size 1 chain of intersections,
			// use the "all" node as the reference pPosition to collect the label nodes.
			Set tNodeNo = ""
			For n=1:1:pPosition {
				Set tNodeNo = $O(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",1,"all",tNodeNo))
				Quit:(tNodeNo="")
			} 
		}
		ElseIf (pAxis>0) {
			// This is a result axis, use the requested position information
			Set tNodeNo = $G(@..%ResultCacheLocation@(tCubeIndex,..%QueryKey,"leaf",pAxis,pPosition))
		}
		
		
		// ===== NODE ADDITION =====
		// This goes backwards from leaf nodes
		
		// Collect the nodes from the axis global, noting the existence of any orsets.
		While ((tAxisKey'="")&&(tNodeNo'="")) {
			Set tNode = $G(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",tNodeNo))
			Set tType = $$$dsAxisNodeTypeGet(tNode)
			Set tParent = $$$dsAxisNodeParentGet(tNode)
			
			If (tType = "axis") {
				Quit
			}
			ElseIf (tType="orset") {
				// Note that there is an orset in the label chain
				Set tOrsetLabelNodes(tNodeNo) = ""
			}

			Set pNodeArray(tNodeNo) = tNode
			Set tNodeNo = tParent
		}
		
		
		// ====== NODE REMOVAL ======
		// This goes forward through the collected nodes
		
		// Aggregate processing
		Set tNodeNo = $O(pNodeArray(""),1,tNode)
		While (tNodeNo'="") {
			// DTB - Traverse the node array and set some to hidden
			Set tType = $$$dsAxisNodeTypeGet(tNode)
			Set tAggParent = $$$dsAxisNodeAggParentGet(tNode)
			
			If (tAggParent'="")&&(tNodeNo'=tAggParent) {
				// DTB - Hide labels for aggregate arguments
				Set tHideLabel(tNodeNo) = ""
			}
			
			Set tNodeNo = $O(pNodeArray(tNodeNo),1,tNode)
		}

		
		
		// ORSET processing - Traverse the array of nodes contributing to the label. 
		// For each orset encountered, note that all but the final label in that orset should be removed.
		If $D(tOrsetLabelNodes) {
			Set tCurrentOrset = 0
			Set tNodeNo = $O(tOrsetLabelNodes(""))
			Set tNode = pNodeArray(tNodeNo)
			
			While tNodeNo'="" {
				Set tType = $$$dsAxisNodeTypeGet(tNode)
				Set tParent = +$$$dsAxisNodeParentGet(tNode)
				If (tType="orset") {
					// Note that an orset has begun, and which node is its root
					Set tHideLabel(tNodeNo) = ""
					Set tCurrentOrset = tNodeNo
				}
				ElseIf (tCurrentOrset)  {
					If '((tType="mbr")||(tType="orset")||(tType="ortuple")) {
						// This node is not a legal member of orset, and so its parent is the final orset member
						Set tCurrentOrset = 0
						Kill tHideLabel(tParent)
					}
					Else {
						// Note that everything within the orset should have no label.
						// The final member will be not be known until it is left behind so
						// it cannot be removed when first encountered here.
						Set tHideLabel(tNodeNo) = ""
					}
				}

				Set tLastNodeNo = tNodeNo
				// DP-426458 - Consult the original axis order for ORSET chains. This is not necessarily in ascending numeric order
				Set tNodeNo = $O(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",tNodeNo,"ch",""))
				Set:(tNodeNo'="") tNode = $G(pNodeArray(tNodeNo))
			}
			
			If tCurrentOrset {
				// This is the case where there was only an orset, and so it was left open
				Kill tHideLabel(tLastNodeNo)
			}
		}
		
		// Prune the node array to contain only items that are label components
		Set tRemoveNodeNo = $O(tHideLabel(""))
		While (tRemoveNodeNo'="") {
			Kill pNodeArray(tRemoveNodeNo)
			Set tRemoveNodeNo = $O(tHideLabel(tRemoveNodeNo))
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Find the axis key(s) for the item with ordinal position
/// <var>pPosition</var> within axis <var>pAxis</var> (1 = cols, 2 = rows).<br/>
/// Returns, via <var>pKey</var> an array of labels associated with the item
/// from the most specific to the most general.<br/>
/// If the item on the axis has no key (for example, measures), a placeholder "" is inserted into
/// the pKey array to preserve the same structure as returned by <method>%GetOrdinalLabel</method>.<br>
/// The return value is the number of keys returned.<br/>
Method %GetOrdinalKey(Output pKey As %String, pAxis As %Integer, pPosition As %Integer, Output pSpec) As %Integer
{
	// Method added by DTB232
	Kill pKey
	Kill pSpec
	Set tKeyCount = 0
	Set tCubeIndex = ..%CubeKey
	Set tAxisKey = $G(@..%ResultCacheLocation@(tCubeIndex,..%QueryKey,"axis",pAxis))
	Set tNodeNo = $G(@..%ResultCacheLocation@(tCubeIndex,..%QueryKey,"leaf",pAxis,pPosition))
	While ((tAxisKey'="")&&(tNodeNo'="")) {
		Set tNode = $G(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",tNodeNo))
		Set tType = $LG(tNode,1)
		Set tParent = $LG(tNode,4)
		Set tKey = $LG(tNode,13)
		Set tLabel = $LG(tNode,5)
		Set tDimNo = +$LG(tNode,9)
		Set tHierNo = +$LG(tNode,10)
		Set tLevelNo = +$LG(tNode,11)
		If (tType = "axis") {
			Quit
		}

		If (tLabel'="")||(tType="lit") {		// DTB761 - A literal null is a valid key
			Set tKeyCount = tKeyCount + 1
			Set pKey(tKeyCount) = tKey
			
			// Return the level spec
			Set tSC = ##class(%DeepSee.Utils).%GetDimensionSpec(tCubeIndex,.tSpec,tDimNo,tHierNo,tLevelNo)
			Set pSpec(tKeyCount) = tSpec
		}
		Set tNodeNo = tParent
	}
	Quit tKeyCount
}

/// Get the total associated with the given row (1-based).<br/>
Method %GetRowTotal(pRow As %Integer, pAgg As %String = "sum") As %String
{
	Set:pAgg="" pAgg="sum"
	Quit $G(@..%ResultCacheLocation@(..%CubeKey,..%QueryKey,"total",2,pRow,pAgg))
}

/// Get the total associated with the given column (1-based).<br/>
Method %GetColumnTotal(pColumn As %Integer, pAgg As %String = "sum") As %String
{
	Set:pAgg="" pAgg="sum"
	Quit $G(@..%ResultCacheLocation@(..%CubeKey,..%QueryKey,"total",1,pColumn,pAgg))
}

/// Get the grand total for the current query.<br/>
/// This is a simple sum of all cells and not an "aggregate".
Method %GetGrandTotal(pAgg As %String = "sum") As %String
{
	Quit $G(@..%ResultCacheLocation@(..%CubeKey,..%QueryKey,"total"))
}

/// Utility method.<br/>
/// Assemble the query plan for this query.
/// The query must have been successfully executed.
Method %GetPlan(Output pPlan) As %Status
{
	Set tSC = $$$OK
	Try {
		Kill pPlan
		Set tStatus = ..%GetQueryStatus(..%Cube,..%QueryKey)
		If (tStatus < 100) {
			Set tSC = $$$ERROR($$$GeneralError,"Query must be executed before its plan can be displayed.")
			Quit
		}
		Set tSC = ..%GetPlanForQuery(.pPlan,..%Cube,..%QueryKey)
		If $$$ISERR(tSC) Quit
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Show plan details for the given query.
/// Do not call this directly.
Method %GetPlanForQuery(ByRef pPlan, pCubeName As %String, pQueryKey As %String, pLevel As %Integer = 0) [ Internal, Private ]
{
	Set tSC = $$$OK
	Try {
		Set tCubeIndex = $$$DeepSeeIndex(pCubeName)
		// query text
		Set tText = $G(@..%ResultCacheLocation@(tCubeIndex,pQueryKey,"query",1))

		Set tParent = $I(pPlan)
		Set pPlan(tParent) = $LB($S(pLevel>0:"subquery",1:"query"),tText)

		// get plan for this query
		Set tKey = $O(@..%ResultCacheLocation@(tCubeIndex,pQueryKey,"plan",""))
		While (tKey '= "") {
			Set tInfo = @..%ResultCacheLocation@(tCubeIndex,pQueryKey,"plan",tKey)
			Set tStep = $LG(tInfo,1)
			Set tCube = $LG(tInfo,2)
			Set tParm = $LG(tInfo,3)
			Set tParm2 = $LG(tInfo,4)
			If (tStep = "sq") { // subquery
				Set tNodeNo = pPlan + 1
				If ((tParm'="")&&(tCube'="")) {
					Set tSC = ..%GetPlanForQuery(.pPlan,tCube,tParm,pLevel+1)
					If $$$ISERR(tSC) Quit
				}
				Set pPlan(tParent,"ch",tNodeNo) = tCube_":"_tParm
			}
			ElseIf (tStep = "dim") {
				Set pPlan($I(pPlan)) = $LB("dim",tParm,tParm2)
				Set pPlan(tParent,"ch",pPlan) = ""
			}
			ElseIf (tStep = "exec") {
				Set pPlan($I(pPlan)) = $LB("exec",tParm,tParm2)
				Set pPlan(tParent,"ch",pPlan) = ""
			}
			ElseIf (tStep = "execA") {
				Set pPlan($I(pPlan)) = $LB("execA",tParm,tParm2)
				Set pPlan(tParent,"ch",pPlan) = ""
			}
			ElseIf (tStep = "cons") {
				Set pPlan($I(pPlan)) = $LB("consolidate")
				Set pPlan(tParent,"ch",pPlan) = ""
			}
			ElseIf (tStep = "listing") {
				Set pPlan($I(pPlan)) = $LB("listing",tParm)
				Set pPlan(tParent,"ch",pPlan) = ""
			}
			Set tKey = $O(@..%ResultCacheLocation@(tCubeIndex,pQueryKey,"plan",tKey))
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Utility method.<br/>
/// Print out the plan for this query to the console.
/// The query must have been successfully executed.
Method %ShowPlan()
{
	Set tStatus = ..%GetQueryStatus(..%Cube,..%QueryKey)
	If (tStatus < 100) {
		Write "Query must be executed before its plan can be displayed.",!
		Quit
	}
	Do ..%ShowPlanForQuery(..%Cube,..%QueryKey)
}

/// Show plan details for the given query.
Method %ShowPlanForQuery(pCubeName As %String, pQueryKey As %String, pLevel As %Integer = 0) [ Internal, Private ]
{
	If ((pCubeName="")||(pQueryKey="")) {
		Quit
	}
	Set tCubeIndex = $$$DeepSeeIndex(pCubeName)

	// query text
	Set tIndent = (pLevel*3)
	Set tText = $G(@..%ResultCacheLocation@(tCubeIndex,pQueryKey,"query",1))
	Write ?tIndent,"-------------- ","Query Plan"," ---------------------",!
	Write ?tIndent,"**",tText,"**",!

	// show plan for this query
	Set tKey = $O(@..%ResultCacheLocation@(tCubeIndex,pQueryKey,"plan",""))
	While (tKey '= "") {
		Set tInfo = @..%ResultCacheLocation@(tCubeIndex,pQueryKey,"plan",tKey)
		Set tStep = $LG(tInfo,1)
		Set tCube = $LG(tInfo,2)
		Set tParm = $LG(tInfo,3)
		Set tParm2 = $LG(tInfo,4)
		If (tStep = "sq") {
			Write ?tIndent,"**SUBQUERY**",!
			If ((tParm'="")&&(tCube'="")) {
				Do ..%ShowPlanForQuery(tCube,tParm,pLevel+1)
			}
			Else {
				Write ?tIndent,"No query info",!
			}
		}
		ElseIf (tStep = "dim") {
			Write ?tIndent,"**DIMENSION QUERY (",tParm2,"): ",tParm,"**",!
		}
		ElseIf (tStep = "exec") {
			Write ?tIndent,"**EXECUTE: ",tParm,"x",tParm2," task(s) **",!
		}
		ElseIf (tStep = "execA") {
			Write ?tIndent,"**EXECUTE PARALLEL: ",tParm,"x",tParm2," task(s) **",!
		}
		ElseIf (tStep = "cons") {
			Write ?tIndent,"**CONSOLIDATE**",!
		}
		ElseIf (tStep = "listing") {
			Write ?tIndent,"**LISTING QUERY:",tParm," **",!
		}
	
		Set tKey = $O(@..%ResultCacheLocation@(tCubeIndex,pQueryKey,"plan",tKey))
	}
	Write ?tIndent,"-------------- ","End of Plan"," -----------------",!
}

/// Utility method.
/// Print the results of the current query to the console.<br/>
/// If <var>pShowNodeNo</var> is true, show the internal node numbers.<br/>
/// If <var>pMaxRows</var> is defined, limit the number of rows displayed.<br/>
Method %Print(Output pStats, pShowNodeNo As %Boolean = 0, pMaxRows As %Integer = 0) As %Status
{
	Set tSC = $$$OK
	Try {
		If ((..%Query.queryType = "CREATE")||(..%Query.queryType = "DROP")) {
			Quit
		}

		// wait a small time in case a background has not yet reported a error
		Hang 0.01

		Set pMaxRows = $S(pMaxRows>10:pMaxRows-10,1:0)

		Set tError = $G(@..%ResultCacheLocation@(..%CubeKey,..%QueryKey,"error"))
		If (tError'="") {
			Set tSC = tError
		}

		If $$$ISERR(tSC) {
			Do $System.Status.DisplayError(tSC)
			W !
			Set tSC = $$$OK
			Quit
		}

		Set tStatus = ..%GetStatus()
		If (tStatus < 100) {
			Write $$$Text("Result has errors or is not ready to be printed. Status: ","%DeepSee"),tStatus,!
			Quit
		}
		Set tAxisCount = ..%GetAxisCount()
		Set tShowNodeNums = pShowNodeNo

		If (..%Query.queryType = "DRILLTHROUGH") {
			Do ..%PrintListing()
			If (..%Query.showPlan) {
				Do ..%ShowPlan()
			}
			Quit
		}

		// test for default format
		Set tDefFormat = $G(@..%ResultCacheLocation@(..%CubeKey,..%QueryKey,"format"))

		If (tAxisCount=0) {
			// single value answer
			Set tValue = ..%GetValue()
			Set tCellWidth = 20
			Write $$$Text("Result","%DeepSee"),":"
			// JMD1412
			If ((tValue'="")&&(tDefFormat'="")) {
				Write $J(..%FormatNumber(tValue,tDefFormat),tCellWidth),!
			}
			Else {
				Write $J($S(tValue="":"*",tValue'=+tValue:tValue,1:$FN(tValue,",")),tCellWidth),!
			}
			If (..%Query.showPlan) {
				Do ..%ShowPlan()
			}
			Quit
		}

		For a = 1:1:tAxisCount {
			Set tAxisSize(a) = ..%GetAxisSize(a)
			Set tAxisIsSearch(a) = ..%Query.axes.GetAt(a).%IsSearch()		// DTB141
		}

		Set tVolume = ..%GetCellCount(..%CubeKey,..%QueryKey,.tSC)
		If $$$ISERR(tSC) {
			Do $System.Status.DisplayError(tSC)
			Quit
		}

		// Get row and column info
		Set tStart = $ZH
		Set tColCount = +$G(tAxisSize(1))

		If ((tVolume = 0)||(tColCount=0)) {
			Write $$$Text("ResultSet has found no results","%DeepSee"),!
			// Write "Volume: ",tVolume,?20,"Columns: ",tColCount,!
			If (..%Query.showPlan) {
				Do ..%ShowPlan()
			}
			Quit
		}

		// JMD1406: if we have a 3rd axis, pick up its format
		Set tZCount = +$G(tAxisSize(3))
		If (tZCount>0) {
			Set z = ..%GetOrdinalLabel(.tZNames,3,1,.tZFormat,.tZSolveOrder)
			Set tDefFormat = tZFormat
		}

		// column headers
		For c=1:1:$G(tAxisSize(1)) {
			Set tLabelCount = ..%GetOrdinalLabel(.tNames,1,c,.tFormat,.tSolveOrder)
			Set tName = $G(tNames(1))
			Set:tFormat'="" tColFormat(c) = tFormat
			Set:tSolveOrder>0 tColSolveOrder(c) = tSolveOrder
			If (tShowNodeNums) {
				Set tColNodes(c) = $G(@..%ResultCacheLocation@(..%CubeKey,..%QueryKey,"leaf",1,c))
			}
			Set tColNames(c) = tName
		}

		Set tHasRows = 1
		Set tRowCount = +$G(tAxisSize(2))
		If (tRowCount < 1) {
			Set tHasRows = 0
			Set tRowCount = 1
		}

		Set tLblWidth = 18
		Set tTotal = 0
		Set tCells = 0
		Set tEmptyCells = 0

		Set tHasOverride = ..%HasCellFormatOverride()

		// print
		Set tDisplayedColCount = tColCount
		Set tTruncated = 0
		If (tDisplayedColCount > 6) {
			Set tDisplayedColCount = 6
			Set tTruncated = 1
		}
		If (tDisplayedColCount = 1) {
			Set tLblWidth = 24
		}
		Set tCellWidth = (80 \ (tDisplayedColCount + 1)) - 4
		Set:tCellWidth>18 tCellWidth = 18 
		For c = 1:1:tDisplayedColCount {
			Set tName = $E(tColNames(c),1,tCellWidth-$S(tShowNodeNums:4,1:0)) _ $S(tShowNodeNums:"["_tColNodes(c)_"]",1:"")
			Write ?(c-1)*(tCellWidth+3)+tLblWidth,$J(tName,tCellWidth)
		}
		Write:tTruncated ?76,"..."
		Write !

		// how many digits are needed for row #
		Set tRowDigits = 0
		If (tRowCount>1) {
			Set tRowDigits = (1+$ZLOG(tRowCount))\1
			Set tLblWidth = tLblWidth - tRowDigits
		}

		Set tRowsSkipped = 0
		For r = 1:1:tRowCount {
			Set tRowSolveOrder = 0
			Set tName = ""		// DTB141
			If (tHasRows) {
				Set tLabelCount = ..%GetOrdinalLabel(.tLabels,2,r,.tRowFormat,.tRowSolveOrder)
				For n=tLabelCount:-1:1 {
					Set tName = tName _ $S(tName="":"",1:"->")_ tLabels(n)
				}
			}
			ElseIf tAxisIsSearch(1) {		// DTB141
				Set tName = $$$Text("Results","%DeepSee")
			}
			
			Set tCells = tCells + tColCount
			If (pMaxRows>0) {
				If ((r > pMaxRows)&&('tRowsSkipped)) {
					Write ".......","rows not displayed",".......",!
					Set tRowsSkipped = 1
					Continue
				}
				ElseIf ((r > pMaxRows)&&(r < (tRowCount-10))) {
					// show last 10 rows
					Continue
				}
			}

			Set tName = $E(tName,1,$S(tShowNodeNums:tLblWidth-4,1:tLblWidth))
			If (tShowNodeNums) {
				Set tName = tName _ "[" _ $G(@..%ResultCacheLocation@(..%CubeKey,..%QueryKey,"leaf",2,r)) _ "]"
			}
			// Show row # as well
			Write:tRowDigits>0 $J(r,tRowDigits)," "
			Write tName
			For c = 1:1:tDisplayedColCount {
				Set tValue = $Case(tAxisCount,
					1:..%GetOrdinalValue(c),
					:..%GetOrdinalValue(c,r))

				If (+$G(tColSolveOrder(c))>=+tRowSolveOrder) {
					Set tFormat = $S($G(tColFormat(c))'="":tColFormat(c),$G(tRowFormat)'="":tRowFormat,1:tDefFormat)
				}
				Else {
					Set tFormat = $S($G(tRowFormat)'="":tRowFormat,$G(tColFormat(c))'="":tColFormat(c),1:tDefFormat)
				}

				// JMD988 Test for format override
				If ((tAxisCount>1) && tHasOverride) {
					Set tFO = ..%GetCellFormatOverride(c,r)
					Set:tFO'="" tFormat = tFO
				}

				Set tTotal = tTotal + tValue
				Set:tValue="" tEmptyCells = tEmptyCells + 1

				If (tFormat'="") {
					Write ?(c-1)*(tCellWidth+3)+tLblWidth+tRowDigits+1,$J($S(tValue="":"*",tValue'=+tValue:tValue,1:..%FormatNumber(tValue,tFormat)),tCellWidth)
				}
				Else {
					Write ?(c-1)*(tCellWidth+3)+tLblWidth+tRowDigits+1,$J($S(tValue="":"*",tValue'=+tValue:tValue,tValue'=(tValue\1):$FN(tValue,",",2),1:$FN(tValue,",")),tCellWidth)
				}
			}
			Write:tTruncated ?76,"..."
			Write !
		}

		Set pStats("cells") = tCells
		Set pStats("empty") = tEmptyCells
		Set pStats("total") = tTotal
		Set ..%Statistics("Cells") = tCells
		Set ..%Statistics("Print") = $ZH - tStart

		If (..%Query.showPlan) {
			Do ..%ShowPlan()
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If $$$ISERR(tSC) {
		Do $System.Status.DisplayError(tSC)
	}
	Quit tSC
}

/// Utility method.<br/>
/// For a DRILLTHROUGH query, print out the listing.
Method %PrintListing()
{
	Set tSC = $$$OK
	Try {
		Set tSC = ..%GetListingResultSet(.tRS,.tListingFields)
		If $$$ISERR(tSC) Quit
		Set tColumnMeta = tRS.%GetMetaData().columns
		If (tListingFields="") {		
			Set tColCount = tColumnMeta.Count()
		}
		Else {
			Set tColCount = $LL(tListingFields)
		}
	
		Write "   #"
		Set tColWidth = $S(tColCount<5:15,tColCount<6:12,tColCount<7:11,tColCount<8:10,1:5)

		If (tListingFields="") {		
			For c = 1:1:tColCount {
				Set tColInfo = tColumnMeta.GetAt(c)
				Write ?(((c-1)*tColWidth)+6),$E(tColInfo.colName,1,tColWidth-1)
			}
		}
		Else {
			For c = 1:1:tColCount {
				Write ?(((c-1)*tColWidth)+6),$E($LG(tListingFields,c),1,tColWidth-1)
			}
		}
		Write !

		Set n = 0
		While (tRS.%Next(.tSC)) {
			If $$$ISERR(tSC) Quit
			Set n = n + 1
			Write $J(n,4),":"
			For c=1:1:tColCount {
				If (tListingFields="") {
					Set tValue = tRS.%GetData(c)
				}
				Else {
					Set tValue = tRS.%Get($LG(tListingFields,c))
				}
				Write ?(((c-1)*tColWidth)+6),$E(tValue,1,tColWidth-1)
			}
			Write !
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If $$$ISERR(tSC) {
		Do $System.Status.DisplayError(tSC)
		Write !
	}
}

/// Lower-level function that, given the text of a DeepSee MDX query, <var>pMDX</var>, 
/// parses it and converts it to a DeepSee run-time query object without changing
/// the state of this Result Set.
Method %ParseMDX(pMDX As %String, pQuery As %DeepSee.Query.query) As %Status
{
	Set tSC = $$$OK
	Try {
		// parse the query
		Set tStart = $ZH
		Set tSC = ##class(%DeepSee.Query.Parser).%ParseMDX(pMDX,.pQuery,..%Trace)  // DTB108 - pass query by reference
		Set ..%Statistics("ParseMDX") = $ZH - tStart
		If $$$ISERR(tSC) Quit

		// JMD1140: test for %LISTING
		If (pQuery.%listing'="") {
			Set ..listing = pQuery.%listing
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Get information on the members of a specific axis within the current query.<br/>
/// <var>pAxis</var> is the axis number (1 = cols, 2 = rows, etc.), 0 indicates that
/// information for the slicer axis is to be returned.<br/>
/// Because it is impossible to pre-determine the size of a specific axis, the process
/// private global, <b>^||DeepSee.AxisMembers</b> is used to hold the results.
/// The caller is responsible for killing this global.<br/>
/// On return, <var>pKey</var> contains the top-level subscript for the process private global
/// under which the member information is stored.<br/>
/// The member information takes the form:<br/>
/// ^||DeepSee.AxisMembers(pKey,pAxis,j,k) = $LB(nodeno,text,dimName,hierName,levelName,memberKey,dimNo,hierNo,levelNo,[aggregate])<br/>
/// pKey is the key returned by this method.<br/>
/// pAxis is the axis number.<br/>
/// j is the ordinal position of the tuple within the axis.<br/>
/// k is the ordinal position of the member within the tuple. k is 0 for members that form a stand-alone tuple.
/// Otherwise k starts at 0 and increase towards the end of the tuple.<br/>
/// nodeno is the internal node number corresponding to the member within its axis.<br/>
/// text is the axis caption for the member.<br/>
/// Names are not enclosed within [ ] delimiters.<br/>
/// A fully-qualified name (UNAME) can be constructed by combining the names with the key:<br/>
/// Set tUName = "["_tDimName_"].["_tHierName_"].["_tLevelName_"].&["_tMemberKey_"]"<br/>
/// If <var>pItemNo</var> is provided, then it is the ordinal number of a single member within
/// the axis and only information about this member is returned.<br/>
Method %GetAxisMembers(pAxis As %Integer, Output pKey, pItemNo As %Integer = "") As %Status
{
	Set tSC = $$$OK
	Try {
		If '$IsObject(..%Query) {
			Set tSC = $$$ERROR($$$ResultNotPrepared)
			Quit
		}
		Set pKey = ..%QueryKey
		If (pKey = "") {
			Set tSC = $$$ERROR($$$NoQueryKey)
			Quit
		}

		Set tIsSlicer = 0
		Set tAxisKey = ""
		If (+pAxis > 0) {
			Set tCount = ..%GetAxisCount(.tAxisInfo)
			Set tAxisKey = $G(tAxisInfo(+pAxis))
		}
		ElseIf (+pAxis=0) {
			// slicer: special case
			Set tIsSlicer = 1
			Set tAxisKey = $G(@..%ResultCacheLocation@(..%CubeKey,pKey,"axis",0))
		}

		// add cube name to key
		Set pKey = ..%CubeKey_":"_pKey

		If (tAxisKey="") {
			Quit
		}
		Else {
			Kill ^||DeepSee.AxisMembers(pKey,pAxis)
			Set n = 0
			Set tCube = $$$UPPER(..%Cube)
			Set tCubeIndex = ..%CubeKey

			Set tAxisKey = $G(@..%ResultCacheLocation@(tCubeIndex,..%QueryKey,"axis",pAxis))

			// walk down leaf list for this axis
			// n.b., we shouldn't use "all": it may not be in the right order
			// (but there is no evidence of that!)

			Set tInfo = ""
			If (tIsSlicer) {
				Set tNodeNo = $O(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",1,"all",""))
			}
			Else {
				Set tLeafNo = $O(@..%ResultCacheLocation@(tCubeIndex,..%QueryKey,"leaf",pAxis,""),1,tNodeNo)
				Set:tLeafNo="" tNodeNo = ""
			}
			While (tNodeNo '= "") {
				Set n = n + 1
				If ((pItemNo="")||(pItemNo=n)) {
					Set tNode = $G(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",tNodeNo))
					Set tType = $$$dsAxisNodeTypeGet(tNode)
					Set tParent = $$$dsAxisNodeParentGet(tNode)
					Set tText =	$$$dsAxisNodeLabelGet(tNode)
					Set tKey = $Case(tType,"mbr":$$$dsAxisNodeValueGet(tNode),:"")
					Set tRSpec = $$$dsAxisNodeRelSpecGet(tNode)

					If (tType="agg") {
						// this is an aggregate: construct the set of its children
						Set tAgg = $$$dsAxisNodeKeyGet(tNode)

						// $LB(nodeno,label,dimname,hiername,levelname,memberKey,rSpec)
						// for agg, dimname="" and hiername is agg name
						Set k = 0
						Set tSpec = $LB(+tNodeNo,tText,"",tAgg)
						Set ^||DeepSee.AxisMembers(pKey,pAxis,n,k) = tSpec

						// loop over children
						Set k2 = 0
						Set cn = $O(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",tNodeNo,"ch",""))
						While (cn'="") {
							Set k2 = k2 + 1
							Set tNode2 = $G(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",cn))
							Set tType2 = $$$dsAxisNodeTypeGet(tNode2)
							Set tParent2 = $$$dsAxisNodeParentGet(tNode2)
							Set tText2 = $$$dsAxisNodeLabelGet(tNode2)
							Set tKey2 = $Case(tType2,"mbr":$$$dsAxisNodeValueGet(tNode2),:"")

							// Find dimension name (if we have already seen this, don't bother)
							Set tDimNo2 = +$$$dsAxisNodeDimGet(tNode2)
							Set tHierNo2 = +$$$dsAxisNodeHierGet(tNode2)
							Set tLevelNo2 = +$$$dsAxisNodeLevelGet(tNode2)
							If ('$D(tDimInfo(tDimNo2,tHierNo2,tLevelNo2),tInfo2)) {
								Set tInfo2 = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo2,tHierNo2,tLevelNo2))
								Set tDimInfo(tDimNo2,tHierNo2,tLevelNo2) = tInfo2
							}
							Set tDimName2 = $LG(tInfo2,2)
							Set tHierName2 = $LG(tInfo2,3)
							Set tLevelName2 = $LG(tInfo2,4)
							Set tSpec2 = $LB(+tNodeNo,tText2,tDimName2,tHierName2,tLevelName2,tKey2,tDimNo2,tHierNo2,tLevelNo2)
							Set ^||DeepSee.AxisMembers(pKey,pAxis,n,k,k2) = tSpec2

							Set cn = $O(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",tNodeNo,"ch",cn))
						}
					}
					Else {
						// Find dimension name (if we have already seen this, don't bother)
						Set tDimNo = +$$$dsAxisNodeDimGet(tNode)
						Set tHierNo = +$$$dsAxisNodeHierGet(tNode)
						Set tLevelNo = +$$$dsAxisNodeLevelGet(tNode)
						If ('$D(tDimInfo(tDimNo,tHierNo,tLevelNo),tInfo)) {
							Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo))
							Set tDimInfo(tDimNo,tHierNo,tLevelNo) = tInfo
						}
						Set tDimName = $LG(tInfo,2)
						Set tHierName = $LG(tInfo,3)
						Set tLevelName = $LG(tInfo,4)

						// $LB(nodeno,label,dimname,hiername,levelname,memberKey,dno,hno,lno,[rspec])
						Set tSpec = $LB(+tNodeNo,tText,tDimName,tHierName,tLevelName,tKey,tDimNo,tHierNo,tLevelNo,tRSpec)

						// WAL032 -- handle %OR members
						// Insert the %OR spec in position 11
						Set tORMemberSpec = $$$dsAxisNodeKeyGet(tNode)
						If (tORMemberSpec [ "|") {
							Set $list(tSpec,11) = tORMemberSpec
						}
						// WAL032

						// The tSpec evaluated thus far is the innermost node of a tuple on an axis. Collect all of the visible nodes of type "mbr" or "msr
						// in the chain by walking up the parents. Since the length of the chain is unknown the ancestor nodes are collected into the temporary
						// array tTempMembers, which once complete is then traversed top-down to place the nodes in ^||DeepSee.AxisMembers in the correct axis order.
						Kill tTempMembers
						Set tTempMembers(tNodeNo) = tSpec		
						While (tParent'="") {
							// get info for parents of this node, if applicable
							Set tParentNode = $G(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",tParent))
							Set tParentType = $LG(tParentNode,1)
							If ((tParentType="axis")) Quit
							If ((tParentType="mbr")||(tParentType="msr")) {
								Set tText = $$$dsAxisNodeLabelGet(tParentNode)
								Set tKey = $$$dsAxisNodeValueGet(tParentNode)
								// Find dimension name (if we have already seen this, don't bother)
								Set tDimNo = +$$$dsAxisNodeDimGet(tParentNode)
								Set tHierNo = +$$$dsAxisNodeHierGet(tParentNode)
								Set tLevelNo = +$$$dsAxisNodeLevelGet(tParentNode)
								If ('$D(tDimInfo(tDimNo,tHierNo,tLevelNo),tInfo)) {
									Set tInfo = $G($$$DeepSeeMetaGLVN("cubes",tCube,"mbr#",tDimNo,tHierNo,tLevelNo))
									Set tDimInfo(tDimNo,tHierNo,tLevelNo) = tInfo
								}
								Set tDimName = $LG(tInfo,2)
								Set tHierName = $LG(tInfo,3)
								Set tLevelName = $LG(tInfo,4)
								// Look at parent node, not info
								Set tParentSpec = $LB(+tParent,tText,tDimName,tHierName,tLevelName,tKey,tDimNo,tHierNo,tLevelNo,$LG(tParentNode,14))
								Set tTempMembers(tParent) = tParentSpec
							}
							Set tParent = $LG(tParentNode,4)
						}
						If $D(tTempMembers) {
							Set tAxisNodeNo=""
							For k=0:1 {
								Set tAxisNodeNo = $O(tTempMembers(tAxisNodeNo),1,tTempSpec)
								Quit:tAxisNodeNo=""
								Set ^||DeepSee.AxisMembers(pKey,pAxis,n,k) = tTempSpec
							}
						}
					}
				}
				If (tIsSlicer) {
					Set tNodeNo = $O(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",1,"all",tNodeNo))
				}
				Else {
					Set tLeafNo = $O(@..%ResultCacheLocation@(tCubeIndex,..%QueryKey,"leaf",pAxis,tLeafNo),1,tNodeNo)
					Set:tLeafNo="" tNodeNo = ""
				}
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Clear out current statistics for this result set.
Method %ClearStatistics()
{
	Kill ..%Statistics
}

/// Get the value of a specific query statistic. e.g. "ParseMDX".<br/>
/// For "query" stats, add "query." to the stat name: e.g. ""query.Slices".
Method %GetStatistic(pStat As %String) As %String
{
	Set tValue = ""
	If (pStat'="") {
		If ($E($$$LOWER(pStat),1,6)="query.") {
			Set pStat = $E(pStat,7,*)
			If ($IsObject(..%Query)) {
				If (pStat="Slices") {
					// special case:
					Set tValue = 0
					Set tTotalAxisCount = ##class(%DeepSee.Query.Engine2).%GetAxisInfo(..%CubeKey,..%QueryKey,.tAxisType,.tAxisKey,.tAxisSize,.tSlicerAxis)
					// sometimes the slicer is treated as a normal 3rd axis
					If ((tSlicerAxis=0)&&(tTotalAxisCount=3)) {
						Set tSlicerAxis = 3
					}
					If (tSlicerAxis>0) {
						Set tValue = +$G(tAxisSize(tSlicerAxis))
					}
				}
				Else {
					Set tValue = $G(..%Query.%Statistics(pStat))
				}
			}
		}
		Else {
			Set tValue = $G(..%Statistics(pStat))
		}
	}
	Quit tValue
}

/// Write out current statistics for this result set.
Method %PrintStatistics()
{
	If ($IsObject(..%Query)) {
		Do ..%Query.%PrintStatistics()
	}

	Write !
	Write "ResultSet Statistics:",!
	Write " Cells:",?25,$$FormatNum($G(..%Statistics("Cells"))),!
	Write " Parse:",?25,$$FormatMS($G(..%Statistics("ParseMDX"))),!
	Write " Display:",?25,$$FormatMS($G(..%Statistics("Print"))),!
	Write " Total Time:",?25,$$FormatMS($G(..%Statistics("ParseMDX"))+$G(..%Statistics("Print"))),!
	Quit

	Set (t,n) = ""
FormatMS(t)
	Quit $J($FN(t*1000,",",3),15)_" ms"

FormatNum(n)
	Quit $J($FN(n,",",0),15)
}

/// Apply MDX FORMAT_STRING <var>pFormat</var> to numeric value <var>pValue</var>.
ClassMethod %FormatNumber(pValue As %Decimal, pFormat As %String, Output pType As %String, Output pStyle As %String) As %String
{
	Set tOutput = ""
	Set pStyle = ""

	// there may be a style spec tacked on after a ^
	Set tStyleSpec = $P(pFormat,"^",2)
	Set pFormat = $P(pFormat,"^",1)

	// special case for dates
	If ((pFormat = "yyyy-mm-dd")||(pFormat = "%date%")) {
		Set pStyle = $P(tStyleSpec,";",1)_";"
		Set pType = "date"
		If (+pValue<=0) Quit ""
		If (pFormat = "%date%") {
			Quit $ZDT(pValue\1,,,,,4,,,,,"@err")		// DTB369 - Add 4 digit year format
		}
		Else {
			Quit $ZDT(pValue\1,3,,,,,,,,,"@err")
		}
	}
	//+ begin JSL4423
	// special case for duration of time (pValue is expressed in seconds)
	If ($e(pFormat,1,6) = "%time%") {
		Set pStyle = $P(tStyleSpec,";",1)_";"
		Set pType = "integer"
		if pValue < 0 {
			Set pValue = $ZABS(pValue)
			Set tNegativeFlag = 1
			Set pStyle = $P(tStyleSpec,";",2)_";"
		}
		// if less than 1 day, use $ztime
		if pValue < 86400 {
			Set tResult = $ztime(pValue,1,,"")
		} else {
			Set tDays = pValue\86400
			Set tValue = pValue#86400
			Set tResult=$ztime(tValue,1,,"")
			Set tHours = $p(tResult,":",1)
			Set $p(tResult,":",1)= tDays*24+tHours
		}
		quit $S('$g(tNegativeFlag):"",1:"-")_tResult
	}
	//- end JSL4423
	Set tFormat = ""
	// JMD988: test for numeric string or special "%string%" format
	// JMD1001: Skip pValue=""
	// 
	// JMD1378: Don't let "0.25" trick us; convert it to .25
	Set:$IsValidNum(pValue) pValue = +pValue

	If ((pValue'="")&&('$IsValidNum(pValue)||(pValue'=+pValue)||(pFormat="%string%"))) {
		Set pType = "string"
		Set pStyle = $P(tStyleSpec,";",1)_";"
		Quit pValue
	}
	Else {
		Set pType = $S(pValue=(pValue\1):"integer",1:"number")
		If (pValue > 0) { // positive
			Set tFormat = $P(pFormat,";",1)
			Set pStyle = $P(tStyleSpec,";",1)
		}
		ElseIf (pValue < 0) {  // negative
			Set tFormat = $P(pFormat,";",2)
			Set:tFormat'="" pValue = pValue * -1
			Set pStyle = $P(tStyleSpec,";",2)
		}
		ElseIf (pValue = 0) {  // zero
			Set tFormat = $P(pFormat,";",3)
			Set pStyle = $P(tStyleSpec,";",3)
		}
		ElseIf (pValue = "") { // missing
			Set tFormat = $P(pFormat,";",4)
			Set pStyle = $P(tStyleSpec,";",4)
			// JMD1001 (2)
			If (tFormat="") {
				Quit ""
			}
		}
	}

	If (pStyle="") {
		Set pStyle = $P(tStyleSpec,";",1)
	}
	If (pStyle'="") {
		Set pStyle = pStyle _ ";"
	}	
	
	Set:tFormat="" tFormat = $P(pFormat,";",1)
	If (tFormat="") {
		// default numeric format
		If (pValue>=0) {
			Quit $FN(pValue,",",$S(pType="integer":0,1:2))
		}
		Else {
			Quit "("_$FN(-pValue,",",$S(pType="integer":0,1:2))_")"
		}
	}

	// apply format
	Set tHasPerCent = tFormat["%"
	Set tHasComma = tFormat[","
	Set tHasZero = tFormat["0"
	Set tHasHash = (tFormat["#")||tHasZero

	Set:tHasPerCent pValue = pValue*100

	// JMD909 - Leading 0s
	Set tLeading0s = 0
	If (tHasZero) {
		// find leading zeroes
		Set t = 1
		While (t<=$L(tFormat)) {
			Set ch = $E(tFormat,t)
			If ((ch="#")||(ch=0)) {
				Set tLeading0s = tLeading0s + 1
			}
			ElseIf ((ch=".")) {
				Quit
			}
			Set t = t + 1
		}
		// now treat 0 as #
		Set tFormat = $Replace(tFormat,"0","#")
	}

	Set tPre = $TR($P(tFormat,"#",1),"\","")
	Set tPost = $S(tHasHash:$TR($P(tFormat,"#",$L(tFormat,"#")),"\",""),1:"")
	Set tScale = 0
	Set d = $F(tFormat,".")
	While (($E(tFormat,d)="#")||($E(tFormat,d)="0")) {
		Set tScale = tScale + 1
		Set d = d + 1
	}

	Set tOutput = $S(tHasHash:$FN(pValue,$S(tHasComma:",",1:""),tScale),1:"")
	// + WAL156 && Sascha Kisser
	Set tDS=##class(%SYS.NLS.Format).GetFormatItem("DecimalSeparator")
	Set:(tDS="") tDS = "."
	Set:tHasZero tOutput = $TR($J($P(tOutput,tDS,1),tLeading0s)," ",0)_$S(tScale>0:tDS,1:"")_$P(tOutput,tDS,2)
	// - WAL156 && Sascha Kisser
	Quit tPre _ tOutput _ tPost
}

/// Internal method.<br>
/// Local implementation of DataModel API.
Method %CopyDataFromModel(Output pData, Output pTypes, pSeries As %Integer = "") As %Status [ Internal ]
{
	Set tSC = $$$OK
	Try {
		Set tStatus = ..%GetQueryStatus(..%Cube,..%QueryKey)
		Set tAxisCount = ..%GetAxisCount()

		If (tAxisCount = 0) {
			// single value answer
			Set pData(1,"Result") = ..%GetValue()
			Quit
		}

		// series = column
		// prop # = row

		For a = 1:1:tAxisCount {
			Set tAxisSize(a) = ..%GetAxisSize(a)
		}

		Set tVolume = ..%GetCellCount(..%CubeKey,..%QueryKey,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		If (tVolume = 0) {
			// no results !!!
			Quit
		}


		// Get row info: rows are properties
		Set tHasRows = 1
		Set tRowCount = +$G(tAxisSize(2))
		If (tRowCount < 1) {
			Set tRowCount = 1
		}

		For sno = $S(pSeries="":1,1:pSeries):1:..%seriesCount {
			For r = 1:1:tRowCount {
				Set tValue = $Case(tAxisCount,
					1:..%GetOrdinalValue(sno),
					:..%GetOrdinalValue(sno,r))
					Set pData(sno,r) = tValue
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
}

/// Internal method.<br>
/// Called by controller to get meta data for the current query.
/// Each metadata value is a csv list.
Method %GetModelInfo(Output pPropNames As %String, Output pPropTypes As %Integer, Output pPropLabels As %String) As %Status [ Internal ]
{
	Set tSC = $$$OK
	Try {
		Set pPropNames = ""
		Set pPropTypes = ""
		Set pPropLabels = ""

		Set tStatus = ..%GetQueryStatus(..%Cube,..%QueryKey)
		Set tAxisCount = ..%GetAxisCount()

		If (tAxisCount = 0) {
			// single value answer
			Set pPropNames = "Result"
			Set pPropTypes = 12
			Set pPropLabels = $$$Text("Result","%DeepSee")
			Quit
		}

		For a = 1:1:tAxisCount {
			Set tAxisSize(a) = ..%GetAxisSize(a)
		}

		Set tVolume = ..%GetCellCount(..%Cube,..%QueryKey,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		If (tVolume = 0) {
			// no results !!!
			Quit
		}

		// columns are series
		Set tColCount = +$G(tAxisSize(1))
		Set ..%seriesCount = tColCount

		// column headers
		For c=1:1:$G(tAxisSize(1)) {
			Set tLabelCount = ..%GetOrdinalLabel(.tNames,1,c,.tFormat)
			Set ..%seriesNames(c) = $G(tNames(1))
		}

		// Get row info: rows are properties
		Set tHasRows = 1
		Set tRowCount = +$G(tAxisSize(2))
		If (tRowCount < 1) {
			Set tHasRows = 0
			Set tRowCount = 1
		}

		// Get names from rows
		For r = 1:1:tRowCount {
			If (tHasRows) {
				Set tName = ""
				Set tLabelCount = ..%GetOrdinalLabel(.tLabels,2,r,.tRowFormat)
				For n=tLabelCount:-1:1 {
					Set tName = tName _ $S(tName="":"",1:".")_ tLabels(n)
				}
			}
			Else {
				Set tName = $$$Text("Results","%DeepSee")
			}

			Set pPropNames = pPropNames _ $S(r=1:"",1:",") _ r
			Set pPropTypes = pPropTypes _ $S(r=1:"",1:",") _ 12
			Set pPropLabels = pPropLabels _ $S(r=1:"",1:",") _ tName
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
}

/// Find and return an MDX slicer statement that will return the specified range of cells in
/// the current query as a one-cell result.<br/>
/// For convenience, return the measure in play, if possible to determine.
Method %GetSlicerForCellRange(Output pSlicer As %String, pStartRow As %Integer, pStartCol As %Integer, pEndRow As %Integer, pEndCol As %Integer, Output pMeasure As %String) As %Status
{
	// deprecated: use %GetFiltersForCellRange instead
	Set tSC = $$$OK
	Try {
		Set pSlicer = ""
		Set pMeasure = ""

		Set tCubeIndex = ..%CubeKey
		Set tCubeName = $$$UPPER(..%Cube)
		Set tQueryKey = ..%QueryKey
		If ((tCubeIndex="")||(tQueryKey="")) {
			Set tSC = $$$ERROR($$$GeneralError,"Query not executed")
			Quit
		}
		If ('$D(@..%ResultCacheLocation@(tCubeIndex,tQueryKey))) {
			Set tSC = $$$ERROR($$$GeneralError,"No query found for key")
			Quit
		}

		// !!! what if axis count != 2
		Set tAxisCount = ..%AxisCount
		If (tAxisCount="") {
			Set tAxisCount = ..%GetAxisCount()
		}

		Set tColAxis = 1
		Set tRowAxis = 2
		Set tAxisKey = $G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"axis",tRowAxis))

		// expression for rows
		Kill tSpecList
		For tRow = pStartRow:1:pEndRow {
			Set tNodeNo = $G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"leaf",tRowAxis,tRow))
			If (tNodeNo="") {
				Continue
			}
			Set tNodeInfo = $G(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",tNodeNo))
			Set tParent = $LG(tNodeInfo,4)
			Set tNodeType = $LG(tNodeInfo,1)
			Set tId = $LG(tNodeInfo,6)
			Set tKey = $LG(tNodeInfo,13)
			Set tDimNo = $LG(tNodeInfo,9)
			Set tHierNo = $LG(tNodeInfo,10)
			Set tLevelNo = $LG(tNodeInfo,11)
			If (((tNodeType="msr")||(tId'=""))&&(tDimNo '= "")&&(tHierNo '= "")&&(tLevelNo '= "")) {
				Set tMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tDimNo,tHierNo,tLevelNo))
				Set tMbrType = $LG(tMbrInfo,1)
				Set tSpec = ""
				If (tMbrType="r") {
					// tack on remote spec
					Set tRemoteSpec = $LG(tNodeInfo,14)
					If (tRemoteSpec'="") {
						Set tSpec = "["_$LG(tMbrInfo,2)_"]"_"."_tRemoteSpec
					}
				}
				ElseIf (tNodeType="msr") {
					Set pMeasure = $LG(tMbrInfo,3)
				}
				Else {
					// JMD909 - fix for drill on Properties()
					If (($LG(tMbrInfo,2)'="")&&($LG(tMbrInfo,3)'="")&&($LG(tMbrInfo,4)'="")&&(tKey'="")) {
						Set tSpec = "["_$LG(tMbrInfo,2)_"].["_$LG(tMbrInfo,3)_"].["_$LG(tMbrInfo,4)_"].&["_$$$dsEscapeIdent(tKey)_"]"
					}
				}

				// if any parent nodes are members, construct a tuple
				// check for relations in parents as well
				Set tIsTuple = 0
				While (tParent'="") {
					Set tPNodeInfo = $G(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",tParent))
					Set tPNodeType = $LG(tPNodeInfo,1)
					If ((tPNodeType="mbr")||(tPNodeType="msr")) {
						Set tPType = $LG(tPNodeInfo,1)
						Set tPId = $LG(tPNodeInfo,6)
						Set tPKey = $LG(tPNodeInfo,13)
						Set tPDimNo = $LG(tPNodeInfo,9)
						Set tPHierNo = $LG(tPNodeInfo,10)
						Set tPLevelNo = $LG(tPNodeInfo,11)
						If (((tPType="msr")||(tPId'=""))&&(tPDimNo '= "")&&(tPHierNo '= "")&&(tPLevelNo '= "")) {
							// JMD1284
							Set:tSpec'="" tIsTuple = 1
							Set tPMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tPDimNo,tPHierNo,tPLevelNo))
							Set tPMbrType = $LG(tPMbrInfo,1)
							Set tPSpec = ""
							If (tPMbrType="r") {
								// tack on remote spec
								Set tRemoteSpec = $LG(tPNodeInfo,14)
								If (tRemoteSpec'="") {
									Set tPSpec = "["_$LG(tPMbrInfo,2)_"]"_"."_tRemoteSpec
								}
							}
							ElseIf (tPType="msr") {
								Set pMeasure = $LG(tPMbrInfo,3)
							}
							Else {
								// JMD909
								If (($LG(tPMbrInfo,2)'="")&&($LG(tPMbrInfo,3)'="")&&($LG(tPMbrInfo,4)'="")&&(tPKey'="")) {
									Set tPSpec = "["_$LG(tPMbrInfo,2)_"].["_$LG(tPMbrInfo,3)_"].["_$LG(tPMbrInfo,4)_"].&["_$$$dsEscapeIdent(tPKey)_"]"
								}
							}
							// JMD1284
							If (tPSpec'=tSpec) {
								Set:tPSpec'="" tSpec = tPSpec_$S(tSpec="":"",1:",")_tSpec
							}
						}
					}
					Set tParent = $LG(tPNodeInfo,4)
				}
				If (tIsTuple) {
					Set:tSpec'="" tSpec = "("_tSpec_")"
				}
				// JMD1284: add to list; remove duplicates
				Set:tSpec'="" tSpecList(tSpec) = ""
			}
		}

		// JMD1284: convert list to set
		Set tRowSpec = ""
		Set kc = 0
		Set tSpec = $O(tSpecList(""))
		While (tSpec'="") {
			Set kc = kc + 1
			Set tRowSpec = tRowSpec _ $S(kc>1:",",1:"") _ tSpec
			Set tSpec = $O(tSpecList(tSpec))
		}
		If (kc>1) {
			Set tRowSpec = "{" _ tRowSpec _ "}"
		}

		// expression for cols
		Kill tSpecList
		Set tAxisKey = $G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"axis",tColAxis))

		For tCol = pStartCol:1:pEndCol {
			Set tNodeNo = $G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"leaf",tColAxis,tCol))
			If (tNodeNo="") {
				Continue
			}
			Set tNodeInfo = $G(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",tNodeNo))
			Set tNodeType = $LG(tNodeInfo,1)
			Set tId = $LG(tNodeInfo,6)
			Set tParent = $LG(tNodeInfo,4)
			Set tKey = $LG(tNodeInfo,13)
			Set tDimNo = $LG(tNodeInfo,9)
			Set tHierNo = $LG(tNodeInfo,10)
			Set tLevelNo = $LG(tNodeInfo,11)
			
			If (((tNodeType="msr")||(tId'=""))&&(tDimNo '= "")&&(tHierNo '= "")&&(tLevelNo '= "")) {
				Set tMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tDimNo,tHierNo,tLevelNo))
				Set tMbrType = $LG(tMbrInfo,1)
				Set tSpec = ""
				If (tMbrType="r") {
					// tack on remote spec
					Set tRemoteSpec = $LG(tNodeInfo,14)
					If (tRemoteSpec'="") {
						Set tSpec = "["_$LG(tMbrInfo,2)_"]"_"."_tRemoteSpec
					}
				}
				ElseIf (tNodeType="msr") {
					Set pMeasure = $LG(tMbrInfo,3)
				}
				Else {
					// JMD909 - fix for drill on Properties()
					If (($LG(tMbrInfo,2)'="")&&($LG(tMbrInfo,3)'="")&&($LG(tMbrInfo,4)'="")&&(tKey'="")) {
						Set tSpec = "["_$LG(tMbrInfo,2)_"].["_$LG(tMbrInfo,3)_"].["_$LG(tMbrInfo,4)_"].&["_$$$dsEscapeIdent(tKey)_"]"
					}
				}
				// if any parent nodes are members, construct a tuple
				Set tIsTuple = 0
				While (tParent'="") {
					Set tPNodeInfo = $G(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",tParent))
					Set tPNodeType = $LG(tPNodeInfo,1)
					If ((tPNodeType="mbr")||(tPNodeType="msr")) {
						Set tPType = $LG(tPNodeInfo,1)
						Set tPId = $LG(tPNodeInfo,6)
						Set tPKey = $LG(tPNodeInfo,13)
						Set tPDimNo = $LG(tPNodeInfo,9)
						Set tPHierNo = $LG(tPNodeInfo,10)
						Set tPLevelNo = $LG(tPNodeInfo,11)
						If (((tPType="msr")||(tPId'=""))&&(tPDimNo '= "")&&(tPHierNo '= "")&&(tPLevelNo '= "")) {
							// JMD1284
							Set:tSpec'="" tIsTuple = 1
							Set tPMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tPDimNo,tPHierNo,tPLevelNo))
							Set tPMbrType = $LG(tPMbrInfo,1)
							Set tPSpec = ""
							If (tPMbrType="r") {
								// tack on remote spec
								Set tRemoteSpec = $LG(tPNodeInfo,14)
								If (tRemoteSpec'="") {
									Set tPSpec = "["_$LG(tPMbrInfo,2)_"]"_"."_tRemoteSpec
								}
							}
							ElseIf (tPType="msr") {
								Set pMeasure = $LG(tPMbrInfo,3)
							}
							Else {
								// JMD909
								If (($LG(tPMbrInfo,2)'="")&&($LG(tPMbrInfo,3)'="")&&($LG(tPMbrInfo,4)'="")&&(tPKey'="")) {
									Set tPSpec = "["_$LG(tPMbrInfo,2)_"].["_$LG(tPMbrInfo,3)_"].["_$LG(tPMbrInfo,4)_"].&["_$$$dsEscapeIdent(tPKey)_"]"
								}
							}
							// JMD1284
							If (tPSpec'=tSpec) {
								Set:tPSpec'="" tSpec = tPSpec_$S(tSpec="":"",1:",")_tSpec
							}
						}
					}
					Set tParent = $LG(tPNodeInfo,4)
				}
				If (tIsTuple) {
					Set:tSpec'="" tSpec = "("_tSpec_")"
				}
				// JMD1284: add to list; remove duplicates
				Set:tSpec'="" tSpecList(tSpec) = ""
			}
		}

		// JMD1284: convert list to set
		Set tColSpec = ""
		Set kc = 0
		Set tSpec = $O(tSpecList(""))
		While (tSpec'="") {
			Set kc = kc + 1
			Set tColSpec = tColSpec _ $S(kc>1:",",1:"") _ tSpec
			Set tSpec = $O(tSpecList(tSpec))
		}
		If (kc>1) {
			Set tColSpec = "{" _ tColSpec _ "}"
		}

		Set tWHERE = ""
		If ((tRowSpec '= "")&&(tColSpec '= "")) {
			// !!! Set tWHERE = "NONEMPTYCROSSJOIN(" _ tRowSpec _ "," _ tColSpec _ ")"
			Set tWHERE = "CROSSJOIN(" _ tRowSpec _ "," _ tColSpec _ ")"
		}
		ElseIf (tRowSpec '= "") {
			Set tWHERE = tRowSpec
		}
		ElseIf (tColSpec '= "") {
			Set tWHERE = tColSpec
		}

		Set tSlicer = $G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"slicer"))
		If (tSlicer '= "") {
			If (tWHERE = "") {
				Set tWHERE = tSlicer
			}
			Else {
				Set tWHERE = "CROSSJOIN(" _ tWHERE _ "," _ tSlicer _ ")"
			}

			// check for measure in slicer (simple case)
			If (pMeasure="") {
				If (tSlicer [ "[MEASURES].") {
					Set pMeasure = $P(tSlicer,"[MEASURES].",2,999)
					Set pMeasure = $P(pMeasure,"]",1)
					Set:$E(pMeasure)="[" pMeasure = $P(pMeasure,"[",2)
				}
			}
		}
		Set pSlicer = tWHERE
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Test for %GetFiltersForCellRange.
ClassMethod %TestFilters(pMDX As %String) As %Status [ Internal ]
{
	Set tSC = $$$OK
	Try {
		Set tRS = ..%New()
		Set tSC = tRS.%PrepareMDX(pMDX)
		If $$$ISERR(tSC) Quit
		Set tSC = tRS.%Execute()
		If $$$ISERR(tSC) Quit
		Set tSC = tRS.%GetFiltersForCellRange(.tFilters,1,1,1,1)
		If $$$ISERR(tSC) Quit
		ZW tFilters
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	If $$$ISERR(tSC) {
		Do $System.Status.DisplayError(tSC)
	}


	Quit tSC
}

/// Find and return a an array of MDX %FILTER statements that will return the specified range of cells in
/// the current query as a one-cell result.<br/>
/// On return, <var>pFilters</var> will contain the filter statement corresponding to each axis (1,2, etc) and the slicer
/// (0).<br/>
/// For convenience, return the measure in play, if possible to determine. For cell ranges with
/// multiple measures, the measure applied to the cell <var>pStartRow</var>, <var>pStartCol</var>
/// is returned.<br/>
Method %GetFiltersForCellRange(Output pFilters As %String, pStartRow As %Integer, pStartCol As %Integer, pEndRow As %Integer, pEndCol As %Integer, Output pMeasure As %String, pAllRows As %Boolean = 0, pAllCols As %Boolean = 0, pSortCol As %Integer = 0, pSortDir As %String = "ASC", ByRef pPluginInfo As %String) As %Status
{
	Set tSC = $$$OK
	Try {
		Kill pFilters
		Set pMeasure = ""
		Set pPluginInfo = "" // WAL170

		Set tCubeIndex = ..%CubeKey
		Set tCubeName = $$$UPPER(..%Cube)
		Set tQueryKey = ..%QueryKey
		If ((tCubeIndex="")||(tQueryKey="")) {
			Set tSC = $$$ERROR($$$GeneralError,"Query not executed")
			Quit
		}
		If ('$D(@..%ResultCacheLocation@(tCubeIndex,tQueryKey))) {
			Set tSC = $$$ERROR($$$GeneralError,"No query found for key")
			Quit
		}
		If (..%GetStatus()<100) {
			Set tSC = $$$ERROR($$$GeneralError,"Query not complete")
			Quit
		}
		
		// + WAL170
		Set tPlugInList = ""
		Set tSC = ##class(%DeepSee.Utils).%GetKPIPlugInList(.tPlugInList)
		If $$$ISERR(tSC) Quit
		// - WAL170

		// we only support 2 axes
		Set tAxisCount = ..%AxisCount
		If (tAxisCount="") {
			Set tAxisCount = ..%GetAxisCount()
		}
		Set tColAxis = 1
		Set tRowAxis = 2
		
		

		// JMD1361: unite row and column logic
		// repeat logic for row and column axis
		For a = 1:1:2 {
			Set tXLat = 0
			If (a=1) {
				Set tCurrAxis = tRowAxis
				Set tAll = pAllRows
				Set tStartItem = pStartRow
				Set tEndItem = $S($G(pEndRow)>0:pEndRow,1:pStartRow)		// DP-409955 - Support single-coordinate cell address
				Set:pSortCol>0 tXLat = 1
			}
			Else {
				Set tCurrAxis = tColAxis
				Set tAll = pAllCols
				Set tStartItem = pStartCol
				Set tEndItem = $S($G(pEndCol)>0:pEndCol,1:pStartCol)		// DP-409955 - Support single-coordinate cell address
			}

			// loop
			Set tAxisKey = $G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"axis",tCurrAxis))
			Set tAxisSpec = ""

			Set tItems = 0
			If ('tAll) {
				For tItemIndex = tStartItem:1:tEndItem {
					// JMD1468 Note that rows are *display* rows and have to be converted to
					// logical rows to account for sorting.
					Set tItemNo = tItemIndex

					If (tXLat) {
						Set tItemNo = $G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"sort",pSortCol,pSortDir,tItemIndex),tItemNo)
					}

					// JMD1397: Use tCubeIndex
					Set tNodeNo = $G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"leaf",tCurrAxis,tItemNo))
					If (tNodeNo="") {
						Continue
					}
					Set tNodeInfo = $G(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",tNodeNo))
					set tAxisSpec = tAxisSpec _ $Select(tAxisSpec="":"",1:",") _ ##class(%DeepSee.Query.Engine).%GetSpecForAxisNode(tCubeIndex,tQueryKey,tCurrAxis,tNodeNo,.pPluginInfo)
					Set tItems = tItems + 1
				}
				
				If (tItems > 1) {
					Set:tAxisSpec'="" tAxisSpec = "{" _ tAxisSpec _ "}"
				}
			}

			// save results
			If (a=1) {
				Set tRowSpec = tAxisSpec
			}
			Else {
				Set tColSpec = tAxisSpec
			}
		}

		Set tSlicer = $G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"slicer"))
		
		Set:tColSpec'="" pFilters(1) = tColSpec
		Set:tRowSpec'="" pFilters(2) = tRowSpec
		Set:tSlicer'="" pFilters(0) = tSlicer
		
		// DP-409955 - Return the measure in effect in the upper left cell of any selection range
		Set pMeasure = ..%GetCellMetric(pStartRow,pStartCol,.tSC)
		Quit:$$$ISERR(tSC)
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Provided a (row,col) cell address within this resultset, determine which measure is being applied.
Method %GetCellMetric(pRow As %Integer = 1, pCol As %Integer = 1, pSC As %Status = {$$$OK}) As %String
{
	// Method added by DP-409955
	// Default to %COUNT, the case where no measure is declared on any axis
	Set tMetric = "%COUNT"
	Set tTestMetric = ""
	
	Try {
		Set tCubeIndex = ..%CubeKey
		Set tCubeName = $$$UPPER(..%Cube)
		Set tQueryKey = ..%QueryKey
		If ((tCubeIndex="")||(tQueryKey="")) {
			Set pSC = $$$ERROR($$$GeneralError,"Query not executed")
			Quit
		}
		If ('$D(@..%ResultCacheLocation@(tCubeIndex,tQueryKey))) {
			Set pSC = $$$ERROR($$$GeneralError,"No query found for key")
			Quit
		}
		If (..%GetStatus()<100) {
			Set pSC = $$$ERROR($$$GeneralError,"Query not complete")
			Quit
		}
		
		// Verify the requested cell is a real cell in the resultset before continuing.
		// Every result has cell (1,1) even if no leaf nodes are defined.
		If ((pCol>1)&&(pRow>1)) &&
			'($D(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"leaf",1,pCol)) &&
			$D(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"leaf",2,pRow))) {
			
			Set pSC = $$$ERROR($$$GeneralError,$$$FormatText("Requested cell (%1,%2) does not exist in the resultset",pCol,pRow))
			Set tMetric = ""
			Quit
		}

		
		// Look through all axes to search for the measure in effect for this cell.
		// For each cell exactly one measure should exist across all axes at this stage
		// so the first declared measure encountered is a sufficient condition to 
		// stop the search.
		Merge tAxis = @..%ResultCacheLocation@(tCubeIndex,tQueryKey,"axis")
		
		Set tAxisNo = $O(tAxis(""),1,tAxisKey)
		While (tAxisNo'="")&&(tTestMetric="") {
			// Fetch the visible axis nodes along the current dimension. The Slicer (axis 0) should
			// always have size 1 so the position is assumed.
			Set tSC = ..%GetOrdinalLabelNodes(tAxisNo,$Case(tAxisNo,0:1,1:pCol,2:pRow,:0),.tNodes)
			Quit:$$$ISERR(tSC)
			
			// Search from the leaf of each axis upward until a metric node is encountered
			Set tNodeNo=$O(tNodes(""),-1,tNodeInfo)
			While (tNodeNo'="")&&(tTestMetric="") {
				Set tNodeType = $LG(tNodeInfo,1)
				If (tNodeType="exp") {
					// There is no single measure here, the number is a calculation. 
					// Return the identifying label for the node.
					Set tTestMetric = $LG(tNodeInfo,5)
				}
				ElseIf (tNodeType="msr") {
					// Since this is a measure we can return the logical name from the metadata.
					Set tMeasureId = $LG(tNodeInfo,7)
					If (tMeasureId="") {
						// This is the default count measure
						Set tTestMetric = "%COUNT"
					}
					Else {
						// Look up the measure's logical name
						Set tFact = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"msr#",tMeasureId))
						Set tTestMetric = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"fact","prop",tFact,"msrname"))
					}
				}
				
				Set tNodeNo=$O(tNodes(tNodeNo),-1,tNodeInfo)
			}
			
			Set tAxisNo = $O(tAxis(tAxisNo),1,tAxisKey)
		}


	}
	Catch ex {
		Set pSC = ex.AsStatus()
	}
	
	Set:(tTestMetric'="") tMetric = tTestMetric
	
	Quit tMetric
}

/// Output the result of the current query in XML/A 
/// format to the current device. The query should be prepared
/// and executed first.<br/>
/// If there is an error, it is assumed that the caller will transform
/// the status value into a SOAP fault.
Method %OutputXMLA() As %Status [ Internal ]
{
	Set tSC = $$$OK
	Try {
		Set tCubeName = $$$UPPER(..%Cube)
		Set tCubeIndex = ..%CubeKey
		Set tQueryKey = ..%QueryKey
		Set tStatus = ..%GetQueryStatus(tCubeName,tQueryKey)
		Set tAxisCount = ..%GetAxisCount()
		For a = 1:1:tAxisCount {
			Set tAxisSize(a) = ..%GetAxisSize(a)
			Set tAxisKeys(a) = $G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"axis",a))
		}

		If (..%Query.queryType = "DRILLTHROUGH") {
			// !!! what to do for DRILLTHROUGH
			Quit
		}

		// find name of cube in original case
		Set tCubeClass = $G($$$DeepSeeMetaGLVN("cubes",tCubeName))
		Set tCubeName = $G($$$DeepSeeMetaGLVN("classes",tCubeClass))

		// timestamps !!!
		Set tLastDataUpdate = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"lastDataUpdate"))
		Set tLastSchemaUpdate = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"lastSchemaUpdate"))

		If (tLastDataUpdate'="") {
			// format is: "2009-06-19T15:55:31"
			Set tLastDataUpdate = $TR($ZDT(tLastDataUpdate,3)," ","T")
		}
		If (tLastSchemaUpdate'="") {
			// format is: "2009-06-19T15:55:31"
			Set tLastSchemaUpdate = $TR($ZDT(tLastSchemaUpdate,3)," ","T")
		}


		// Cube section
		&html<
<root xmlns="urn:schemas-microsoft-com:xml-analysis:mddataset" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<OlapInfo>
<CubeInfo>
<Cube>
<CubeName>#($ZCVT(tCubeName,"O","XML"))#</CubeName>
<LastDataUpdate xmlns="http://schemas.microsoft.com/analysisservices/2003/engine">#(tLastDataUpdate)#</LastDataUpdate>
<LastSchemaUpdate xmlns="http://schemas.microsoft.com/analysisservices/2003/engine">#(tLastSchemaUpdate)#</LastSchemaUpdate>
</Cube>
</CubeInfo>
		>

		// Additional OLAP info

		// Axes info
		&html<<AxesInfo>>
		For a = 1:1:tAxisCount {
			&html<<AxisInfo name="Axis#(a-1)#">>
			// !!!
			&html<</AxisInfo>>
		}
		&html<</AxesInfo>>

		// Cell info
		&html<
<CellInfo>
<Value name="VALUE"/>
<FmtValue name="FORMATTED_VALUE" type="xsd:string"/>
<CellOrdinal name="CELL_ORDINAL" type="xsd:unsignedInt"/>
</CellInfo>
		>

		&html<</OlapInfo>>

		// Results


		// Axes section
		// !!! what if there are 0 axes
		// !!! what about the slicer
		&html<<Axes>>
		For a = 1:1:tAxisCount {
			// for each axis write out the tuples that make up each entry
			&html<<Axis name="Axis#(a-1)#">>
			&html<<Tuples>>
			Set tAxisKey = tAxisKeys(a)

			// walk down leaf index and get node #s for this axis
			Set tItemNo = $O(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"leaf",a,""),1,tNodeNo)
			While (tItemNo '= "") {
				&html<<Tuple>>
				// use node number to get details for the axis node
				// (this comes from the axis cache)
				Set tNode = $G(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",tNodeNo))

				// look up the chain of parents for this node to see what belongs to
				// this *tuple*; assemble a list of nodes
				Kill tNodes
				Set tLevel = 0
				Set tParentNo = $LG(tNode,4)
				Set tParentNode = tNode
				While (tParentNo '= "") {
					Set tType = $LG(tParentNode,1)
					If ((tType = "mbr")||(tType = "msr")||(tLevel=0)) {
						Set tLevel = tLevel + 1
						Set tNodes(tLevel) = tParentNode
					}
					Set tParentNode = $G(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",tParentNo))
					Set tParentNo = $LG(tParentNode,4) // go up
				}

				// walk down list of nodes and emit members for this tuple
				For n = tLevel:-1:1 {
					Set tNode = tNodes(n)
					// pull details out of node
					Set tType = $LG(tNode,1)
					Set tCaption = $LG(tNode,5)
					Set tMbrId = $LG(tNode,6)
					Set tDimNo = +$LG(tNode,9)
					Set tHierNo = +$LG(tNode,10)
					Set tLevelNo = +$LG(tNode,11)

					If ('$D(tMbrInfoCache(tDimNo,tHierNo,tLevelNo),tMbrInfo)) {
						// Avoid going to the meta global by using local cache
						Set tMbrInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeName,"mbr#",tDimNo,tHierNo,tLevelNo))
						Set tMbrInfoCache(tDimNo) = tMbrInfo
					}

					If (tType = "msr") {
						Set tDimName = "[Measures]"
						Set tLevelName = "["_tCaption_"]"
						Set tUName = tDimName_".["_tCaption_"]"
					}
					Else {
						Set tDimName = "["_$LG(tMbrInfo,2)_"]"
						Set tHierName = "["_$LG(tMbrInfo,3)_"]"
						Set tLevelName = "["_$LG(tMbrInfo,4)_"]"
					
						// compute uname
						Set tUName = ""
						Set tDimClass = $LG(tMbrInfo,6)
						If (tDimClass'="") {
							Set tUName = $zobjclassmethod(tDimClass,"%GetMemberSpec",tMbrId,tCubeName,tDimNo,tHierNo,tLevelNo)
						}
						Set tUName = tDimName_"."_tHierName_"."_tUName
					}

					Set tDispInfo = 0 // !!!

					&html<<Member Hierarchy="#($ZCVT(tDimName,"O","XML"))#">>
					&html<<UName>#($ZCVT(tUName,"O","XML"))#</UName>>
					&html<<Caption>#($ZCVT(tCaption,"O","XML"))#</Caption>>
					&html<<LName>#($ZCVT(tLevelName,"O","XML"))#</LName>>
					&html<<LNum>#($ZCVT(tLevelNo,"O","XML"))#</LNum>>
					&html<<DisplayInfo>#($ZCVT(tDispInfo,"O","XML"))#</DisplayInfo>>
					&html<</Member>>
				}

				// end of this tuple
				&html<</Tuple>>
				Set tItemNo = $O(@..%ResultCacheLocation@(tCubeKey,tQueryKey,"leaf",a,tItemNo),1,tNodeNo)
			} 

			&html<</Tuples>>
			&html<</Axis>>
		}
		&html<</Axes>>

		// Cells
		&html<<CellData>>

		// Write out cells in order
		// Initial cell address
		Set tCellNo = 0
		For a=1:1:tAxisCount {
			Set tAxisKey = tAxisKeys(a)
			Set tItemNo(a) = $O(@..%ResultCacheLocation@(tCubeKey,tQueryKey,"leaf",a,""),1,tNodeNo)
			Set tAddr(a) = tNodeNo
		}
		Set tDone = 0
		While ('tDone) {
		Set tValue = $Case(tAxisCount,
			0:..%GetValue(),
			1:..%GetValue(tAddr(1)),
			2:..%GetValue(tAddr(1),tAddr(2)),
			3:..%GetValue(tAddr(1),tAddr(2),tAddr(3)),
			4:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4)),
			5:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4),tAddr(5)),
			6:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4),tAddr(5),tAddr(6)),
			7:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4),tAddr(5),tAddr(6),tAddr(7)),
			:"")
			
			// determine type of the value
			// !!!! n.b, we need to find the actual format string to apply
			// for now we guess
			If ($IsValidNum(tValue)) {
				If (tValue = (tValue\1)) {
					Set tType = "xsd:long"
					Set tFmtValue = $FN(tValue,",",0)
				}
				Else {
					Set tType = "xsd:double"
					Set tFmtValue = $FN(tValue,",",2)
				}
			}
			Else {
				Set tType = "xsd:string"
			}
			&html<<Cell CellOrdinal="#(tCellNo)#"><Value xsi:type="#(tType)#">#(tValue)#</Value><FmtValue>#(tFmtValue)#</FmtValue></Cell>>
			Set tCellNo = tCellNo + 1

			// find next cell
			Set tFoundNext = 0
			Set a = 1
			While ('tFoundNext) {
				Set tItemNo(a) = $O(@..%ResultCacheLocation@(tCubeKey,tQueryKey,"leaf",a,tItemNo(a)),1,tNodeNo)
				If (tItemNo(a) '= "") {
					Set tAddr(a) = tNodeNo
					Set tFoundNext = 1
				}
				Else {
					Set tItemNo(a) = $O(@..%ResultCacheLocation@(tCubeKey,tQueryKey,"leaf",a,""),1,tNodeNo)
					Set tAddr(a) = tNodeNo
					Set a = a + 1
					If (a > tAxisCount) {
						Set tDone = 1
						Quit
					}
				}
			}
		}

		&html<</CellData>>
		&html<</root>>
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Return the default format string for this result.
/// Also returns the default label (measure name).
Method %GetDefaultFormat(Output pCaption As %String) As %String [ Internal ]
{
	Set pCaption = ""
	Set tCubeIndex = ..%CubeKey
	Set tQueryKey = ..%QueryKey

	#; determine default format
	Set tDefaultFormat = ""
	Set tSlicer = $G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"slicer"))

	// JMD1406: if we have a 3rd axis, pick up its format
	If (..%GetAxisSize(3)>0) {
		Set z = ..%GetOrdinalLabel(.tZNames,3,1,.tZFormat,.tZSolveOrder)
		Set tDefaultFormat = tZFormat
		Set pCaption = $G(tZName(z))
	}
	ElseIf (tSlicer'="") {
		Set tSlicerKey = $G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"axis",0))
		If (tSlicerKey'="") {
			Set s = $O(@..%AxisCacheLocation@(tCubeIndex,tSlicerKey,"axes",1,"all",""))
			If (s'="") {
				Set tSNode = $G(@..%AxisCacheLocation@(tCubeIndex,tSlicerKey,"axes",s))
				If ($LG(tSNode,1)="msr") {
					Set tDefaultFormat = $LG(tSNode,12)
					Set pCaption = $LG(tSNode,5)
				}
			}
		}
	}
	If (pCaption="") {
		Set pCaption = ##class(%DeepSee.Utils).%GetCountCaption(tCubeIndex)
	}

	Quit tDefaultFormat
}

/// Output the result of the current query in XML/A 
/// format to the current device. The query should be prepared
/// and executed first.<br/>
/// If there is an error, it is assumed that the caller will transform
/// the status value into a SOAP fault.
Method %OutputJSON(pPageSize As %Integer, pCurrPage As %Integer, pRowLabels As %List = "", pMaxRows As %Integer = "") As %Status [ Internal ]
{
	Set tSC = $$$OK
	Try {
		Set tCubeIndex = ..%CubeKey
		Set tCubeName = $$$UPPER(..%Cube)
		Set tQueryKey = ..%QueryKey
		Set tStatus = ..%GetQueryStatus(..%Cube,tQueryKey)

		If (tStatus < 100) {
			// DP-408372 - Wait in a tight loop for the status to return 100
			Hang 0.05
			// try again
			Set tStatus = ..%GetQueryStatus(..%Cube,tQueryKey)
		}

		If (tStatus < 100) {
			Write "null",!
			Quit
		}

		// window
		Set tMaxCols = 500
		Set tStartRow = ((pCurrPage-1)*pPageSize)+1
		Set tEndRow = tStartRow + pPageSize - 1
		Set tRowCount = 0
		Set tColCount = 0

		// write out *all* rows and let the client page through the results
		// meta data consists of an array of up to 2 axes.
		// Each axis has list of tuples: {c:caption,f:format}
		// these correspond to leaf nodes.
		// and a graph of groups that refer to the tuples:
		// groups:[{caption:'',groups:[...],tuples:[]

		// data consists of a single array of values (cells: q.v.)

		Set tAxisCount = ..%GetAxisCount()
		For a = 1:1:tAxisCount {
			Set tAxisSize(a) = ..%GetAxisSize(a)
			Set tAxisKeys(a) = $G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"axis",a))
		}

		Set tColCount = +$G(tAxisSize(1))
		Set tRowCount = +$G(tAxisSize(2))

		// JMD1462
		Set:tColCount=0 tColCount = 1
		Set:tRowCount=0 tRowCount = 1

		// JMD1128 
		Set tMaxJSONRows = $S(pMaxRows="":2000,1:+pMaxRows)
		Set:tRowCount>tMaxJSONRows tRowCount = tMaxJSONRows
		Set:tColCount>tMaxCols tColCount = tMaxCols

		Set tStartRow = 1
		Set tEndRow = tStartRow + tRowCount - 1

		If (..%Query.queryType = "DRILLTHROUGH") {
			Write "null",!
			Quit
		}	

		#; determine default format
		Set tDefaultFormat = ..%GetDefaultFormat(.tDefaultCaption)

		// find name of cube in original case
		Set tCubeClass = $G($$$DeepSeeMetaGLVN("cubes",tCubeName))
		Set tCubeName = $G($$$DeepSeeMetaGLVN("classes",tCubeClass))

		Write "{"
		Write !,$$$ZENJSPAIR("cubeName",tCubeName),","
		Write !,$$$ZENJSPAIR("cubeClass",tCubeClass),","
		Write !,$$$ZENJSPAIR("defaultFormat",tDefaultFormat),","
		Write !,$$$ZENJSPAIR("defaultCaption",tDefaultCaption),","

		// row level captions
		Write !,"""rowCaptions"":[",!
		Set rc = $O(pRowLabels(""))
		While (rc'="") {
			Write $$$ZENJSVALUE(pRowLabels(rc))
			Set rc = $O(pRowLabels(rc))
			Write:rc'="" ","
		}
		Write "],",! // rowCaptions

		Write !,"""axes"":[",!

		// ?JMD- should we write out tuples post-json?
		If (tAxisCount = 0) {
			// default axes
			Write "{" // axis object
			Write """key"":","null",",",!
			Write """tuples"":[",!
				Set tCaption = "All"
				Write "{" // tuple object
				Write $$$ZENJSPAIR("caption",tCaption)
				Write "}",! // tuple object
			Write "]",! // tuples
			Write "}",! // axis object

			Write ",{",! // axis object
			Write """key"":","null",",",!
			Write """tuples"":[",!
				Set tCaption = "Count"
				Write "{",! // tuple object
				Write $$$ZENJSPAIR("caption",tCaption)
				Write "}",! // tuple object
			Write "]",! // tuples
			Write "}",! // axis object
		}

		// axis info
		For a = 1:1:tAxisCount {
			Set tAxisKey = tAxisKeys(a)
			Set tHasGroups = 0

			// JMD1128: construct set of groups within this axis
			Set tGroupCount = 1	// node # in groups graph
			Kill tGroups		// group info by number, with hierarchy as graph
								// leaf nodes contain leaf #
			Kill tGroupIndex 	// node # to group #

			Write:a>1 ","
			Write "{" // axis object
			Write !,$$$ZENJSPAIR("key",tAxisKey),","
			Write !,"""tuples"":[",!

			// walk down leaf index and get node #s for this axis
			// make sure we only write out values for current page
			If (a = 2) {
				Set tStart = tStartRow
				Set tEnd = tEndRow
			}
			Else {
				Set tStart = 1
				Set tEnd = tMaxCols
			}

			Set n = 0 // items written
			Set item = 0 // actual item #
			Set tItemNo = $O(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"leaf",a,""),1,tNodeNo)
			While ((tItemNo '= "")&&(item<tEnd)) {
				Set item = item + 1
				If (item >= tStart) {
					// use node number to get details for the axis node
					// (this comes from the axis cache)
					Set tNode = $G(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",tNodeNo))

					Set tType = $LG(tNode,1)
					Set tParent = $LG(tNode,4)
					Set tCaption = $LG(tNode,5)
					Set tMbrId = $LG(tNode,6)
					Set tDimNo = +$LG(tNode,9)
					Set tHierNo = +$LG(tNode,10)
					Set tLevelNo = +$LG(tNode,11)
					Set tFmt = $LG(tNode,12)
					Set tGroupNo = ""

					// JMD: test if we are showing a date value;
					// these may need to be reformatted on the client
					Set tKey = ""
					Set tDateType = ""
					If ((tDimNo'="")&&(tHierNo'="")&&(tLevelNo'="")) {
						If '$D(tMbrTypes(tDimNo,tHierNo,tLevelNo)) {
							Set tDimInfo = $G($$$DeepSeeMetaGLVN("cubes",tCubeIndex,"mbr#",tDimNo,tHierNo,tLevelNo))
							Set tTimeClass = $LG(tDimInfo,6)
							Set tDType = ##class(%DeepSee.Utils).%GetTimeLevelType(tTimeClass)		// DTB188 - Use API

							Set tMbrTypes(tDimNo,tHierNo,tLevelNo) = tDType
						}
						Set tDateType = $G(tMbrTypes(tDimNo,tHierNo,tLevelNo))
					}
					Set:tDateType'="" tKey = $LG(tNode,13)

					// JMD1128: test if we are part of a group
					If (tParent'="") {
						If $D(tGroupIndex(tParent)) {
							// point to existing group
							Set tGroupNo = tGroupIndex(tParent)
						}
						Else {
							// build list of parents above this node
							Kill tPList
							Set pn = 0
							While (tParent'="") {
								Set tParentNode = $G(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",tParent))
								Set tParentType = $LG(tParentNode,1)
								If ((tParentType="mbr")||(tParentType="msr")) {
									Set tHasGroups = 1
									Set tPList(pn) = tParent
									Set pn = pn + 1
								}
								Set tParent = $LG(tParentNode,4)
							}

							// now walk down the list
							Set tLastParent = 0
							Set pn = $O(tPList(""),-1)
							While (pn'="") {
								Set tParent = tPList(pn)
								If $D(tGroupIndex(tParent)) {
									Set gc = tGroupIndex(tParent)
								}
								Else {
									Set gc = tGroupCount
									Set tGroupCount = tGroupCount + 1
								}
								Set tGroupIndex(tParent) = gc
								Set tGroups(gc) = tParent
								Set tGroups(tLastParent,"ch",gc) = ""
								Set tLastParent = gc
								Set tGroupNo = gc
								Set pn = $O(tPList(pn),-1)
							}
						}
					}

					Set n = n + 1
					If (tGroupNo'="") {
						Set tGroups(tGroupNo,"leaf",n) = ""
					}

					Write:n>1 ","
					Write "{" // tuple object
					Write $$$ZENJSPAIR("caption",tCaption)
					Write:tDateType'="" ",", $$$ZENJSPAIR("type",tDateType)
					Write:tKey'="" ",", $$$ZENJSPAIR("key",tKey)
					Write:tGroupNo'="" ",",$$$ZENJSPAIR("g",tGroupNo)
					Write:tFmt'="" ",",$$$ZENJSPAIR("format",tFmt)
					Write "}",! // tuple object
				}
				Set tItemNo = $O(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"leaf",a,tItemNo),1,tNodeNo)
			}
			Write "]" // tuples

			Write ",""hasGroups"":",$S(tHasGroups:"true",1:"false"),!

			// JMD1128: groups and children
			If $D(tGroups) {
				//Do ..%OutputAxisGroupJSON(.tGroups,0,tCubeIndex,tAxisKey)
				// JMD1148: write out flat list of groups
				Write ",""groups"":["
				Set gn = 0
				Set g = $O(tGroups(""))
				While (g'="") {
					Set tCaption = ""
					Set tParentNo = ""
					Set tNodeNo = $G(tGroups(g))
					If (tNodeNo'="") {
						Set tGroupNode = $G(@..%AxisCacheLocation@(tCubeIndex,tAxisKey,"axes",tNodeNo))
						Set tCaption = $LG(tGroupNode,5)
						Set tParentNo = $LG(tGroupNode,4)
					}
					Set gn = gn + 1
					Write:gn>1 ","
					Write "{" // group object
					Write:tCaption'="" $$$ZENJSPAIR("caption",tCaption),","
					If (tParentNo'="") {
						Set tParentGroup = $G(tGroupIndex(tParentNo))
						Write:tParentGroup'="" $$$ZENJSPAIR("g",tParentGroup),","
					}
					If $D(tGroups(g,"ch")) {
						Write """groups"":["
						Set gc = $O(tGroups(g,"ch",""))
						While (gc'="") {
							Write gc
							Set gc = $O(tGroups(g,"ch",gc))
							Write:gc'="" ","
						}
						Write "],"
					}
					If $D(tGroups(g,"leaf")) {
						Write """tuples"":["
						Set gc = $O(tGroups(g,"leaf",""))
						While (gc'="") {
							Write gc
							Set gc = $O(tGroups(g,"leaf",gc))
							Write:gc'="" ","
						}
						Write "]"
					}
					Write "}",! // group object

					Set g = $O(tGroups(g))
				}
				Write "]",!

			}

			Write "}",! // axis object
		}

		Write "],",! // axes


		// Initial cell address
		For a=1:1:tAxisCount {
			Set tAxisKey = tAxisKeys(a)
			Set tItemNo(a) = $O(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"leaf",a,""),1,tNodeNo)
			Set tAddr(a) = $G(tNodeNo)
		}

		// write out size of data;
		// this allows us to use 1 array for all data values

		Write $$$ZENJSPAIR("rowCount",tRowCount),",",!
		Write $$$ZENJSPAIR("columnCount",tColCount),",",!

		// cells
		// note: we only write out up to 2D results as our client has no use for
		// higher order information
		// JMD1148: simplify JSON for data
		// fastest way is to not use pure JSON!
		// instead, define an array of known-size and explicitly insert values into it.
		// data is written out as [R1C1,R1C2,R1C3,R2C1,R2C2,R2C3]
		Write """cells"":[],",!

		Write """rowTotals"":[],",!
		Write """columnTotals"":[],",!

		Write $$$ZENJSPAIR("grandTotal",+$G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"total"))),",",!

		Write $$$ZENJSPAIR("status",tStatus),! // last property
		Write "}"

		// JMD1148: violate JSON rules for speed's sake:
		Write ";",!

		// cells
		Write "var a = new Array(",tRowCount*tColCount,");",!
		Write "o.data.cells = a;",!

		If (tAxisCount = 0) {
			Write "a[0]="_$$$ZENJSVALUE(..%GetValue())_";",!
		}
		ElseIf (tAxisCount = 1) {
			Set tRowCount = 1
			Set c = 0
			While((tItemNo(1)'="")&&(c<tMaxCols)) {
				Write "a["_c_"]="_$$$ZENJSVALUE(..%GetValue(tAddr(1)))_";",!
				Set c = c + 1
				Set tItemNo(1) = $O(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"leaf",1,tItemNo(1)),1,tNodeNo)
				Set tAddr(1) = tNodeNo
			}
		}
		Else {
			Set tCellCount = 0
			Set row = 0 // actual row #
			While((tItemNo(2)'="")&&(row<tEndRow)) {
				Set row = row + 1
				If (row >= tStartRow) {
					Set c = 0
					Set tItemNo(1) = $O(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"leaf",1,""),1,tNodeNo)
					Set tAddr(1) = tNodeNo
					While((tItemNo(1)'="")&&(c<tMaxCols)) {
						Set c = c + 1
						Set tValue = $Case(tAxisCount,
							0:..%GetValue(),
							1:..%GetValue(tAddr(1)),
							2:..%GetValue(tAddr(1),tAddr(2)),
							3:..%GetValue(tAddr(1),tAddr(2),tAddr(3)),
							4:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4)),
							5:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4),tAddr(5)),
							6:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4),tAddr(5),tAddr(6)),
							7:..%GetValue(tAddr(1),tAddr(2),tAddr(3),tAddr(4),tAddr(5),tAddr(6),tAddr(7)),
							:"")
						Write "a["_tCellCount_"]="_$$$ZENJSVALUE(tValue)_";",!
						Set tCellCount = tCellCount + 1

						Set tItemNo(1) = $O(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"leaf",1,tItemNo(1)),1,tNodeNo)
						Set tAddr(1) = tNodeNo
					}
				}
				Set tItemNo(2) = $O(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"leaf",2,tItemNo(2)),1,tNodeNo)
				Set tAddr(2) = tNodeNo
			}
		}
		// row "totals"
		Write "var a = new Array(",tRowCount,");",!
		Write "o.data.rowTotals = a;",!

		Set r = 0 // rows written
		For tRow = 1:1:tRowCount {
			Write "a["_r_"]="
			Set r = r + 1
			If $D(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"total",2,tRow)) {
				Write "{"
				Write $$$ZENJSPAIR("count",$G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"total",2,tRow,"count"))),","
				Write $$$ZENJSPAIR("sum",$G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"total",2,tRow,"sum"))),","
				Write $$$ZENJSPAIR("min",$G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"total",2,tRow,"min"))),","
				Write $$$ZENJSPAIR("max",$G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"total",2,tRow,"max"))),","
				Write $$$ZENJSPAIR("avg",$G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"total",2,tRow,"avg"))),","
				Write $$$ZENJSPAIR("pct",$G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"total",2,tRow,"pct")))
				Write "};",!
			}
			Else {
				Write "null;",!
			}
		}

		// column "totals"
		Write "var a = new Array(",tColCount,");",!
		Write "o.data.columnTotals = a;",!

		For tCol = 1:1:tColCount {
			Write "a["_(tCol-1)_"]="

			If $D(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"total",1,tCol)) {
				Write "{"
				Write $$$ZENJSPAIR("count",$G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"total",1,tCol,"count"))),","
				Write $$$ZENJSPAIR("sum",$G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"total",1,tCol,"sum"))),","
				Write $$$ZENJSPAIR("min",$G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"total",1,tCol,"min"))),","
				Write $$$ZENJSPAIR("max",$G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"total",1,tCol,"max"))),","
				Write $$$ZENJSPAIR("avg",$G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"total",1,tCol,"avg"))),","
				Write $$$ZENJSPAIR("pct",$G(@..%ResultCacheLocation@(tCubeIndex,tQueryKey,"total",1,tCol,"pct")))
				Write "};",!
			}
			Else {
				Write "null;",!
			}
		}
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
		Write "/*"
		Do $System.OBJ.DisplayError(tSC)
		Write "*/"
	}
	Quit tSC
}

/// If the given query has pending results (such as from plug-ins), update them.
/// Return if there are any additional pending results.
Method %UpdatePendingResults(Output pPending As %Boolean) As %Status
{
	Set tSC = $$$OK
	Try {
		Set pPending = 0
		// DP-428451 - Require the status is greater than 50, at which point APIs begin polling the query's pending flag
		Set:(..%GetStatus() > 50) tSC = ##class(%DeepSee.Query.Engine).%UpdatePendingResults(..%CubeKey,..%QueryKey,.pPending)
	}
	Catch(ex) {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Run the query audit code. (Test version).<br/>
/// This gives customer applications a chance to audit the queries run by DeepSee.
/// This is called whenever a query is executed by %DeepSee.ResultSet.<br/>
/// The query audit code is a valid ObjectScript expression stored in the ^DeepSee.AuditQueryCode global.
/// Audit query code should not write any output to the current device nor
/// should this code kill any % variables required by Zen or DeepSee.<br/>
/// The variable, %dsQuery, will contain the text of the query.
Method %RunQueryAuditCode(pQuery As %DeepSee.Query.query) As %Status
{
	// DTB065: This does the actual work of running the query code.
	Set tSC = $$$OK
	Try {
		Set tAuditCode = $G(^DeepSee.AuditQueryCode)
		If (tAuditCode'="") {
			New %dsCubeName,%dsQueryText,%dsResultSet
			Set %dsCubeName = ..%GetCubeName()
			Set %dsQueryText = ..%GetQueryText()
			Set %dsResultSet = $This
			X tAuditCode
		}
	}
	Catch(ex) {
		Set tSC = $$$ERROR($$$GeneralError,"Error in DeepSee Audit Query Code:" _ $ZE)
	}
	Quit tSC
}

/// Create an SQL table from DeepSee cube context. Arguments:<br>
/// <var>pCubeName</var> (Required) - The name of the cube the new table should be generated from.<br>
/// <var>pNewTableName</var> (Required) - The name of the table or class definition where the new result is to be stored.
/// This must be a valid Schema.Table or Package.Class name, and the current user must have permission to 
/// create this class in the database to which it is mapped.<br>
/// <var>pContext</var> (Optional) - An MDX restriction term which limits the results in the cube. While not required,
/// this is strongly recommended since its ommission will result in the entire cube source being transferred to a table.<br>
/// <var>pListingFields</var> (Optional) - A comma-delimited list of field names to be included in the new table. The field
/// names must exist in the cube's source.<br>
/// <var>pListingName</var> (Optional) - A named listing that is defined for use in the cube. This may be a native listing
/// or a listing defined in a listing group. This will not be used if <var>pListingFields</var> is defined.<br><br>
/// Most commonly this would be called from a KPI Action class. For example, an %OnDashboardAction callback might look like:
/// <example language="cls!member">
///  ClassMethod %OnDashboardAction(pAction As %String, pContext As %ZEN.proxyObject) As %Status
///  {
/// 	Set tSC = $$$OK
/// 	Try {
/// 		Set tFilter = $P(pContext.currFilterSpec," ",2,*)
/// 		Set tNewTableName = "Test.CreateResultTable"
/// 		Set tListingFields = ""
/// 		Set tListingName = "Listing"
/// 		Set tSC = ##class(%DeepSee.ResultSet).%CreateTable(pContext.cubeName, tNewTableName, tFilter, tListingFields, tListingName) 
/// 	}
/// 	Catch ex {
/// 		Set tSC = ex.AsStatus()
/// 	}
/// 
/// 	Quit tSC
///  }
/// </example>
/// For simplicity this example hard codes the name of the new class definition, but this is not recommended in practice. The API will
/// not replace any existing class, returning an error message instead. In order to allow the user to create their own
/// class name, as well as provide the option to set values for tListingFields or tListingName, it is recommended the KPI
/// action launch a popup dialog which manages the user's interaction with these settings and then calls the %CreateTable API.
ClassMethod %CreateTable(pCubeName As %String = "", pNewTableName As %String = "", pContext As %String = "", pListingFields As %String = "", pListingName As %String = "") As %Status
{
	// Method added by DTB434
	Set tSC = $$$OK
	Try {
		If (pCubeName="") {
			Set tSC = $$$ERROR($$$GeneralError,"Cube name must be supplied.")
			Quit
		}
		ElseIf '##class(%DeepSee.Utils).%CubeExists(pCubeName,.tSC) {
			// DTB522 - Return the cube lookup error to the caller
			Quit
		}

		If (pNewTableName="") {
			Set tSC = $$$ERROR($$$GeneralError,"Table name must be supplied.")
			Quit
		}
		Set tNewClassName = $Translate(pNewTableName,"_",".")		// Convert to a class definition name
		Set tListingName = pListingName
		
		If (tListingName="")&&(pListingFields="") {
			// DTB524 - Use default listing if nothing is entered for either field declaration
			
			// First try the default listing method
			Set tCubeClass = ##class(%DeepSee.Utils).%GetCubeClass(pCubeName)
			Set tListingName = $classmethod(tCubeClass,"%GetDefaultListing")
			If (tListingName="") {
				// If the method returned no programmatic default, look directly at the stored model
				Set tListingName = ##class(%DeepSee.Utils).%GetModel(pCubeName).defaultListing
			}
		}
		
		If tListingName'="" {
			// DTB524 - Verify supplied listing name
			// DTB759 - Normalize listing names for lookup
			Set tSC = ##class(%DeepSee.Query.Parser).%ParseMemberSpec(tListingName,.tInfo)
			If $$$ISERR(tSC) Quit
			Set tListingName = tInfo(1)
			
			Set tSC = ##class(%DeepSee.Utils).%GetCubeListings(pCubeName,.tListings)
			If $$$ISERR(tSC) Quit
			
			Set tFound=0
			Set tListing = $O(tListings(""),1,tListingInfo) 
			While tListing'="" {
				If ($$$UPPER(tListing)=$$$UPPER(tListingName)) {
					Set tFound=1
					Quit
				}
				Set tListing = $O(tListings(tListing),1,tListingInfo) 
			}

			If 'tFound {
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Listing %1 is not defined for cube %2.",tListingName,pCubeName))
				Quit
			}
		}
		Set tListingName = "["_tListingName_"]"		// DTB759 - Proceed with normalized ID
		
		// Check for valid class name
		If '$S(tNewClassName'[".":0,1:$ZNAME(tNewClassName,4)) {
			Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Class %1 is not a valid class name.",tNewClassName))
			Quit
		}
		
		// Check permissions on the DB that this result is to be written to
		Set tWrite = 0
		Set tPackageName = $P(tNewClassName,".",1,*-1)
		Set tPackageDB = ##class(%SYS.Namespace).GetPackageDest($Namespace,tPackageName)
		
		Do ##class(%SYS.Namespace).GetNSInfo("^"_tPackageDB,.tDBInfo)
		Set tResource = $G(tDBInfo("Resource"))
		If ((tResource'="") && $System.Security.Check(tResource,"WRITE")) {
			Set tWrite = 1
		}
		
		If 'tWrite {
			Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("User %1 does not have permission to write to package %2",$UserName,tPackageName))
		}

		If ##class(%Dictionary.ClassDefinition).%ExistsId(tNewClassName) {
			Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Class %1 already exists. %CreateTable must generate a class with a unique name.",tNewClassName))
			Quit
		}

		Set tParms("%cube") = pCubeName 
		Set tParms("%tableName") = tNewClassName 
		Set tParms("%listingFields") = pListingFields
		Set tParms("%listingName") = tListingName
		Set tSC = $classmethod("%DeepSee.PlugIn.CreateTable","%GetKPIValue","%DeepSee.CreateTable",.tResult,"CREATETABLE",1,.tParms,pContext,,,"",.tKPIStatus)
		
		If $$$ISOK(tSC)&&$$$ISERR(tKPIStatus) {
			// DTB524 - An internal error might have been returned via the cell result instead of the method status.
			Set tSC = tKPIStatus
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Add a subquery resultset to the list of objects needed to complete this query.
/// Returns zero if there was a failure to set the resultset into the list. Returns
/// the index of the resutlset in the array when successful.
Method %SetSubqueryResultset(pRS As %DeepSee.ResultSet = {$$$NULLOREF}, pStatus As %Status) As %Integer
{
	// Method added by DTB768
	Set pStatus = $$$OK
	Set tRSIdx = 0
	
	Try {
		If '$IsObject(pRS) {
			Set pStatus = $$$ERROR($$$GeneralError,"Must supply valid resultset to %SetSubqueryResultset.")
			Quit
		}

		Set tRSIdx = $I(..%SubqueryResultSets)
		Set ..%SubqueryResultSets(tRSIdx) = pRS
	}
	Catch ex {
		Set pStatus = ex.AsStatus()
		Set tRSIdx = 0
	}
	
	Quit tRSIdx
}

/// Initialize this resultset to ready it for executing a new query. This may be called on a newly instantiated 
/// ResultSet or on a ResultSet that has already been used to execute a different MDX query.
Method %InitializeResultSet() As %Status
{
	// Method Added by DTB739
	Set tSC = $$$OK
	
	Try {
		Kill ..%SubqueryResultSets		// DTB - Remove any instances of subqueries from previous executions
		
		Set tSC = ..%ClearLockKeys("exclusive")
		If $$$ISERR(tSC) Quit
		
		// Reset the cache pointers to use the common cache
		If (..%UseLocal) {
			Set tSC = ..%ClearLocalResult()
			If $$$ISERR(tSC) Quit
			
			Set ..%UseLocal=0
		}
		Set ..%ResultCacheLocation = $Name($$$DeepSeeResultsGLVN)
		Set ..%AxisCacheLocation = $Name($$$DeepSeeAxisGLVN)
		
		// Get a new Session key to create new local cache
		Set ..%SessionKey = $I($$$DeepSeeLocalResultsGLVN("session"))		// DTB788
		
		// DTB820 - Clear query object
		Set ..%Query = ##class(%DeepSee.Query.query).%New()
		
		// DTB964 - Reset state variables
		Set ..listing = ""
		Set ..listingRows = 0
		Set ..listingPageSize = 1000
		Set ..listingPage = 1
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}

	Quit tSC
}

/// Fill the <property>%LockKeys</property> array for the current query. This will only succeed 
/// if the query has been prepared. Keys will be prepended with either "results" or "axis" to indicate 
/// whether the particular key applies to the Results cache or the Axis cache, respectively. This does 
/// not do the actual work of acquiring locks.<br>
/// Once the locks are determined they are immediately copied to the current %Query object using
/// <method>%CopyLockKeysToQuery</method>. The value of the <var>pWait</var> flag is passed through
/// to this method to maintain proper tracking of the lock hierarchy.
Method %SetLockKeys(pRefreshKeys = 0, pWait = 0) As %Status
{
	// Method added by DTB739
	Set tSC = $$$OK
	
	Try {
		// DTB847 - Prevent parameter resolution attempt
		New %dsQueryPrepare
		Set %dsQueryPrepare = 1
		
		Set tQuery = ..%GetQuery()
		If '$IsObject(tQuery) Quit
		
		// Find the master query key
		Set tResultKey = tQuery.%CreateResultKey(.tSC,,pRefreshKeys)		// DTB868 - Pass in key refresh flag
		If $$$ISERR(tSC) Quit
		Set ..%LockKeys($I(..%LockKeys)) = "results:"_tResultKey
		
		// Add the slicer key to the list. The slicer definition is indistiguishable from any other axis declaration
		If $IsObject(tQuery.slicer) {
			Set tSlicerKey = tQuery.%CreateAxisKey(.tSC,"slicer",tQuery.slicer,,,pRefreshKeys)		// DTB868 - Pass in key refresh flag
			If $$$ISERR(tSC) Quit
			Set ..%LockKeys($I(..%LockKeys)) = "axis:"_tSlicerKey
		}
		
		Merge tOriginalAxisText = tQuery.%originalAxisText		// DTB873 - Set up a variable that can be queried with $G()		// DTB967 - Fix typo in variable name
		
		// Add the visible axes to the list
		For a=1:1:tQuery.axes.Count() {
			Set tAxis = tQuery.axes.GetAt(a)
			Set tAxisKey = tQuery.%CreateAxisKey(.tSC,"axis",tAxis,$G(tOriginalAxisText(a)),,pRefreshKeys)		// DTB868 - Pass in key refresh flag	// DTB873 - Pass any %originalAxisText that might be set for this axis
			If $$$ISERR(tSC) Quit
			Set ..%LockKeys($I(..%LockKeys)) = "axis:"_tAxisKey
		}
		
		// DTB943 - Once the lock keys are determined, copy them down to the query object
		Set tSC = ..%CopyLockKeysToQuery(pWait)
		If $$$ISERR(tSC) Quit
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
}

/// Fill the <property>%AncestorLockKeys</property> array for the current ResultSet using the named lock keys defined in
/// <var>pAncestorLocks</var>. This method will support a key set supplied as a comma-delimited string, a $LB, or a COS array.<br>
/// When taking out locks in <method>%AcquireLocks</method> it will be assumed any locks present in this array 
/// are held by a waiting parent process and so these particular locks will be exempted.
Method %SetAncestorLockKeys(ByRef pAncestorLocks) As %Status
{
	// Method added by DTB943
	Set tSC = $$$OK
	
	Try {
		// Test the input for various possible data structures and normailze into the 
		// %AncestorLockKeys 
		If ($D(pAncestorLocks)\10) {
			// The incoming locks are provided in an array. Assume an arbitrary subscript with the
			// lock name in the node's data, the same format as the %LockKeys array
			Set tLockIdx = $O(pAncestorLocks(""),1,tLockKey)
			While (tLockIdx'="") {
				Set ..%AncestorLockKeys(tLockKey) = ""
				
				Set tLockIdx = $O(pAncestorLocks(tLockIdx),1,tLockKey)
			}
		}		
		ElseIf ($G(pAncestorLocks)'="")&&$ListValid($G(pAncestorLocks)) {		// DP-415407
			// The incoming locks are provided in a list
			For n = 1:1:$LL(pAncestorLocks) {
				Set ..%AncestorLockKeys($LG(pAncestorLocks),n) = ""
			}
		}
		ElseIf ($G(pAncestorLocks)'="") {
			// Treat all remaining non-null strings as a comma-delimited list
			For n = 1:1:$L(pAncestorLocks,",") {
				Set ..%AncestorLockKeys($P(pAncestorLocks,",",n)) = ""
			}
		}
		
		// No further action if the input hasn't satisfied one of the above conditions. The null string
		// is a valid input that simply does not set any %AncestorLockKeys and so does not throw
		// an error.
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	Quit $$$OK
}

/// Clear up the locks held by the process and reset the local state variables. If <var>pLockMode</var> is supplied, use it to set the ResultSet's %LockMode.
Method %ClearLockKeys(pLockMode As %String = "") As %Status
{
	// Method added by DTB739
	Set tSC = $$$OK
	
	Try {
		Do ..%ReleaseLocks()
	
		If (pLockMode'="") {
			Set tSC = ..%SetLockMode(pLockMode)
		}
		
		Kill ..%LockKeys		
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
}

/// This method copies the current ResultSet's lock keys into the active query to make the 
/// references available for subqeries and tasks.
/// If <var>pWait</var> is set, this communicates the current ResultSet intends to wait for results
/// and will maintain a hold on the locks securing the current resources.
Method %CopyLockKeysToQuery(pWait = 0) As %Status
{
	// Method added to DTB943
	Set tSC = $$$OK
	
	Try {
		If $IsObject(..%Query) {
			// Clear any previous keys that might have been in this query so
			// the associated query's keys exactly match this Resultset's.
			// The query uses this to set subquery ResultSet's %AncestorLockKeys,
			// so this copying procedure will include the curent AncestorLockKeys to
			// preserve knowledge of locks downward over the entire inheritance chain.
			Kill ..%Query.%LockKeys
			
			// DTB943 - If this resultset is planning to fire off a background task, it will not maintain the
			// locks on the immediate query. These current locks will not be exempted in other tasks
			// that might continue to operate after this ResultSet becomes idle.
			If $D(..%LockKeys)&&pWait {
				Set tLockIdx = $O(..%LockKeys(""),1,tLockKey)
				While tLockIdx'="" {
					// Avoid duplicates by consulting the %AncestorLockKeys index and suppressing any duplicates.
					// That entire index will also be copied into the query's list.
					Set:'$D(..%AncestorLockKeys(tLockKey)) ..%Query.%LockKeys($I(..%Query.%LockKeys)) = tLockKey
					
					Set tLockIdx = $O(..%LockKeys(tLockIdx),1,tLockKey)
				}
			}
			
			// Copy the entire set of %AncestorLockKeys in all situations
			If $D(..%AncestorLockKeys) {
				Set tLockKey = $O(..%AncestorLockKeys(""))
				While tLockKey'="" {
					Set ..%Query.%LockKeys($I(..%Query.%LockKeys)) = tLockKey
					
					Set tLockKey = $O(..%AncestorLockKeys(tLockKey))
				}
			}
		}
	}
	Catch ex {
			Set tSC = ex.AsStatus()
		}
	Quit $$$OK
}

/// Acquire locks needed to secure access to the shared result and axes caches for this query. The parameter <var>pLockMode</var> 
/// controls which type of locks (exclusive/shared) should be attempted, by default this will be the ResultSet's current 
/// <property>%LockMode</property> setting. This method returns either<br>
/// 0 - The method was unable to acquire all of the locks associated with this query<br>
/// 1 - The method has successfully acquired all locks needed to safely interact with the shared cache<br>
/// In the event a "0" is returned, any and all locks acquired by this process are released.<br>
/// Optionally the <var>pTimeout</var> parameter may be supplied to instruct this method to wait for a successful lock on the group
/// of lock keys as a whole. The method will return 1 if all locks are obtained before the requested timeout and 0 otherwise.
/// Optional values for this parameter are:<br>
/// -1 [default] - Make one attempt at obtaining the group of locks and return the result.<br>
/// 0 - Wait indefinitely for all locks in the <property>%LockKeys</property> group to be successfully obtained.<br>
/// (positive number) - Wait up to the specified amount of time and return the success status for the <property>%LockKeys</property> group.
Method %AcquireLocks(pStatus As %Status = {$$$OK}, pLockMode As %String = {..%LockMode}, pTimeout = -1) As %Boolean
{
	// Method added by DTB739
	Set tReturn = 0

	Try {
		If '((pLockMode="exclusive")||(pLockMode="shared")) {
			Set tSC = $$$ERROR($$$GeneralError,"Illegal value supplied to %AcquireLocks: " _ pLockMode)
			Quit
		}
		
		If ((pLockMode=..%LockMode)&&(..%LocksEngaged)) {
			// DTB788 - If the locks are already engaged in this mode, nothing to do here!
			Set tReturn=1
			Quit
		}

		Set tCubeIndex = $$$DeepSeeIndex(..%GetCubeName())
		If (tCubeIndex="") Quit
		
		If $D(..%LockKeys) {
			// DP-432207 - Poll the group of %LockKeys to see if all locks in the group can be obtained simultaneously.
			// Continue attempting until either the requested positive pTimeout is reached or until the locks are obtained
			// if pTimeout=0. For pTimeout=(-1) test the resources only once and move on regardless of the outcome. The "master" lock
			// is obtained and released for every iteration of the loop, and each iteration will last
			//   0.01*(number of unique locks)
			// seconds. Whenever the master lock is avaiable for other processes, either all or none of the %LockKeys will be secured
			// by this method.
			Set tStart = $ZH
			Do {
				Lock +$$$DeepSeeResultLock("master")

				// Re-initialize the tLocksAcquired array to track this execution of the loop 
				Kill tLocksAcquired
				Set tAllLocksAcquired = 1

				Set tKeyIdx = $O(..%LockKeys(""),1,tLockKey)
				While (tKeyIdx'="") && tAllLocksAcquired {
					// DTB943 - Check exemptions to taking out each lock in turn
					Set tLockExempt = $D(..%AncestorLockKeys(tLockKey))
					
					// Provided the lock is not exempted for this ResultSet, proceed with attempts to
					// obtain this lock. Attempt each lock only once.
					If 'tLockExempt && '$D(tLocksAcquired(tLockKey)) {
						// Consult the lock mode
						Lock +$$$DeepSeeResultLock(tCubeIndex,tLockKey)#$S((pLockMode="shared"):"S",1:""):0.01 Set gotLock=$Test
						
						Set:gotLock tLocksAcquired(tLockKey) = ""
						Set tAllLocksAcquired = tAllLocksAcquired && gotLock
					}
					
					Set tKeyIdx = $O(..%LockKeys(tKeyIdx),1,tLockKey)
				}
				
				If 'tAllLocksAcquired {
					// One or more locks failed, release any locks that were successfully obtained.
					Do ReleaseLocksAcquired(.tLocksAcquired,pLockMode)
				}
				Else {
					If ((pLockMode'=..%LockMode)&&(..%LocksEngaged)) {
						// In this situation a second set of locks of differing type is being taken out.
						// Assume this is being called to replace the original set. At this point the 
						// requested locks have been successfully acquired and the original set
						// can be released.
						Do ReleaseLocksAcquired(.tLocksAcquired)
					}
				
					// With any successful acquisition of the entire lock set, update the state 
					// variables appropriately	
					Set tReturn = 1
					Set ..%LocksEngaged = 1
					Set ..%LockMode = pLockMode		// DTB788 - Always confirm lock mode in the RS state
				}
				
				Lock -$$$DeepSeeResultLock("master")
			} While 'tAllLocksAcquired && ((pTimeout > ($ZH-tStart))||'pTimeout)		// DP-432207 - Enforce timout conditions
		}
	}
	Catch ex {
		Set pStatus = ex.AsStatus()
		Set tReturn = 0
		
		// Release any locks that might have been acquired
		Do ReleaseLocksAcquired(.tLocksAcquired,pLockMode)
		
		Lock -$$$DeepSeeResultLock("master")
	}

	Quit tReturn

ReleaseLocksAcquired(tLocksAcquired,tLockMode)
	// DP-432207 - Release all locks that were actually obtained during execution of this method as recorded in the current
	// tLocksAcquired.
	Set:($G(tLockMode)="") tLockMode = ..%LockMode
	Set tLockKey=""
	For {
		Set tLockKey = $O(tLocksAcquired(tLockKey))
		Quit:(tLockKey="")
		
		Lock -$$$DeepSeeResultLock(tCubeIndex,tLockKey)#$S((tLockMode="shared"):"S",1:"")
	}
	Quit
}

/// Release all locks of the type <var>pLockMode</var> held by this ResultSet.
Method %ReleaseLocks(pLockMode As %String = {..%LockMode}) As %Status
{
	// Method added by DTB739
	Set tSC = $$$OK
	
	Try {
		Set tCubeIndex = $$$DeepSeeIndex(..%GetCubeName())
		If (tCubeIndex="") Quit
		
		//Lock +$$$DeepSeeResultLock("master")		// DTB - The moment this method is entered, no need to preserve the integrity of the group 
		If $D(..%LockKeys) {
			Set tKeyIdx = $O(..%LockKeys(""),1,tLockKey)
			While (tKeyIdx'="") {
				// Consult the lock mode
				Lock -$$$DeepSeeResultLock(tCubeIndex,tLockKey)#$S((pLockMode="shared"):"S",1:"")
				
				Set tKeyIdx = $O(..%LockKeys(tKeyIdx),1,tLockKey)
			}
		}
		//Lock -$$$DeepSeeResultLock("master")
		
		Set ..%LocksEngaged = 0
	}
	Catch ex {
		Set tSC = ex.AsStatus()
		//Lock -$$$DeepSeeResultLock("master")
	}
	
	Quit tSC
}

/// Accessor method for changing the <property>%LockMode</property> of this ResultSet. 
/// This is protected from changing the mode when locks are engaged.
Method %SetLockMode(pType = "exclusive") As %Status
{
	// Method added by DTB739
	Set tSC = $$$OK
	
	Try {
		If ..%LocksEngaged {
			Set tSC = $$$ERROR($$$GeneralError,"Cannot change ResultSet lock mode with locks engaged.")
		}
		Else {
			If (pType="exclusive")||(pType="shared") {
				Set ..%LockMode = pType
			}
			Else {
				Set tSC = $$$ERROR($$$GeneralError,"Invalid type provided to %SetLockMode: " _ pType)
			}
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
}

/// Create a local copy of the shared Results and Axis caches and reconfigure the location pointers to the private cache data.
Method %SwitchToLocalCache() As %Status
{
	// Method added by DTB739
	Set tSC = $$$OK
	
	Try {
		// Perform the copy
		Set tSC = ..%CopyResultToLocal()
		If $$$ISERR(tSC) Quit
		
		// Set the state variables to indicate the local cache is complete
		Set ..%UseLocal = 1
		Set ..%ResultCacheLocation = $Name($$$DeepSeeLocalResultsGLVN) _ "(""" _ ..%SessionKey _ """)"
		Set ..%AxisCacheLocation = $Name($$$DeepSeeLocalAxisGLVN) _ "(""" _ ..%SessionKey _ """)"
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
}

/// This method returns the pointers to uing the common cache. 
Method %SwitchToCommonCache() As %Status
{
	// Method added by DTB788
	Set tSC = $$$OK
	
	Try {
		// Set the state variables to indicate the local cache is complete
		Set ..%UseLocal = 0
		Set ..%ResultCacheLocation = $Name($$$DeepSeeResultsGLVN)
		Set ..%AxisCacheLocation = $Name($$$DeepSeeAxisGLVN)
		
		// DTB967
		Set tCubeIndex = $$$DeepSeeIndex(..%GetCubeName())
		Set tQueryKey = ..%QueryKey
		If (tCubeIndex'="")&&(tQueryKey'="") {
			Kill $$$DeepSeeLocalResultsGLVN(..%SessionKey,tCubeIndex,tQueryKey)		// Kill session cache
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
}

/// Look at local cache for reading data
Method %SetLocationLocal() As %Status
{
	Set tSC = $$$OK

	Try {
		Set ..%ResultCacheLocation = $Name($$$DeepSeeLocalResultsGLVN) _ "(""" _ ..%SessionKey _ """)"
		Set ..%AxisCacheLocation = $Name($$$DeepSeeLocalAxisGLVN) _ "(""" _ ..%SessionKey _ """)"
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// Look at common cache for reading data
Method %SetLocationCommon() As %Status
{
	Set tSC = $$$OK

	Try {
		Set ..%ResultCacheLocation = $Name($$$DeepSeeResultsGLVN)
		Set ..%AxisCacheLocation = $Name($$$DeepSeeAxisGLVN)
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
}

/// This does the actual work of copying results from the shared caches to a local copy unique to this ResultSet's 
/// <property>%SessionKey</property>. This operation can only be performed if the ResultSet has locks engaged.
Method %CopyResultToLocal() As %Status
{
	// Method added by DTB739
	Set tSC = $$$OK
	
	Try {
		// This ResultSet must at least have secured the read locks for this query to ensure cache integrity.
		If (..%LocksEngaged) {
			// Verify essential variables are available
			If (..%SessionKey="") {
				Set tSC = $$$ERROR($$$GeneralError,"Invalid %SessionKey for this ResultSet.")
				Quit
			}
			
			Set tCubeIndex = $$$DeepSeeIndex(..%GetCubeName())
			If (tCubeIndex="") {
				Set tSC = $$$ERROR($$$GeneralError,"Could not establish cube index for results copy.")
				Quit
			}
			
			Set tQueryKey = ..%QueryKey
			If (tQueryKey="") {
				Set tSC = $$$ERROR($$$GeneralError,"Could not copy results without a valid query key.")
				Quit
			}
			
			// Proceed with the data copy
			If $D($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey)) {
				Kill $$$DeepSeeLocalResultsGLVN(..%SessionKey,tCubeIndex,tQueryKey)		// DTB788 - Clear old results if they exist
				Merge $$$DeepSeeLocalResultsGLVN(..%SessionKey,tCubeIndex,tQueryKey) = $$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey)
			}
			Else {
				Set tSC = $$$ERROR($$$GeneralError,"No completed results cache for cube/key pair: " _ tCubeIndex _ "/" _ tQueryKey)
			}
			
			Set tKeyIdx = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",""),1,tKey)
			While (tKeyIdx'="") {
				If $D($$$DeepSeeAxisGLVN(tCubeIndex,tKey)) {
					Kill $$$DeepSeeLocalAxisGLVN(..%SessionKey,tCubeIndex,tKey)		// DTB788 - Clear old results if they exist
					Merge $$$DeepSeeLocalAxisGLVN(..%SessionKey,tCubeIndex,tKey) = $$$DeepSeeAxisGLVN(tCubeIndex,tKey)
				}
				Else {
					Set tSC = $$$ERROR($$$GeneralError,"No completed axis cache for cube/key pair: " _ tCubeIndex _ "/" _ tKey)
				}
				If $$$ISERR(tSC) $$$ThrowStatus(tSC)
				
				Set tKeyIdx = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",tKeyIdx),1,tKey)
			}
		}
		Else {
			Set tSC = $$$ERROR($$$GeneralError,"Cannot copy result without locked read access")
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
}

/// Perform the actual work of deleting the local copies of the Results and Axis caches.
Method %ClearLocalResult() As %Status
{
	// Method added by DTB739
	Set tSC = $$$OK

	Try {
		// Verify essential variables are available
		If (..%SessionKey="") {
			Set tSC = $$$ERROR($$$GeneralError,"Invalid %SessionKey for this ResultSet.")
			Quit
		}
		
		Set tCubeIndex = $$$DeepSeeIndex(..%GetCubeName())
		If (tCubeIndex="") {
			Set tSC = $$$ERROR($$$GeneralError,"Could not establish cube index for clearing results.")
			Quit
		}
		
		Set tQueryKey = ..%QueryKey
		If (tQueryKey="") {
			Set tSC = $$$ERROR($$$GeneralError,"Could not clear results without a valid query key.")
			Quit
		}
		
		// Remove the local axis cache first, then the result
		Set tKeyIdx = $O($$$DeepSeeLocalResultsGLVN(..%SessionKey,tCubeIndex,tQueryKey,"axis",""),1,tKey)
		While (tKeyIdx'="") {
			Kill $$$DeepSeeLocalAxisGLVN(..%SessionKey,tCubeIndex,tKey)
			
			Set tKeyIdx = $O($$$DeepSeeLocalResultsGLVN(..%SessionKey,tCubeIndex,tQueryKey,"axis",tKeyIdx),1,tKey)
		}
		
		Kill $$$DeepSeeLocalResultsGLVN(..%SessionKey,tCubeIndex,tQueryKey)
		
		// Reset to indicate the local result is no longer available
		Set ..%UseLocal = 0
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	Quit tSC
}

/// This callback method is invoked by the <METHOD>%Close</METHOD> method to 
/// provide notification that the current object is being closed.
/// 
/// <P>The return value of this method is ignored.
Method %OnClose() As %Status [ Private, ServerOnly = 1 ]
{
	// Method added by DTB736
	Set tSC = $$$OK
	
	Try {
		Set tCubeIndex = $$$DeepSeeIndex(..%GetCubeName())
		Set tQueryKey = ..%GetQueryKey()
		Set tQuery = ..%GetQuery()		// DTB818
		
		// DTB739 - Release all locks
		Do ..%ReleaseLocks()
		
		if ('..%KeepLocalResults) {
			// DTB739 - Clear local results globals
			// DP-408448 - But retain for Component.pivotTable to use
			Do ..%ClearLocalResult()	
		}
		
		// DTB931 - Always clean up the temp table for listings
		If (tCubeIndex'="") && (tQueryKey'="") {
			Kill:('..%KeepLocalResults) $$$DeepSeeListingGLVN(tCubeIndex,tQueryKey)		// DP-410195
		
			// DTB818 - Clear out request nodes if they exist 
			Set tAxisNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",""),1,tAxisKey)
			While tAxisNo'="" {
				Kill $$$DeepSeeAxisGLVN(tCubeIndex,tAxisKey,"request",$$$DeepSeeSessionId)
				
				Set tAxisNo = $O($$$DeepSeeResultsGLVN(tCubeIndex,tQueryKey,"axis",tAxisNo),1,tAxisKey)
			}
		}
	}
	Catch ex {
		Set tSC = ex.AsStatus()
	}
	
	If $$$ISERR(tSC) {
		// DTB739 - Log error information to the log file since the %OnClose return will probably not
		// notify the caller of an error.
		Do ##class(%DeepSee.Utils).%WriteToLog("ResultSet","Error encountered in %OnClose: " _ $system.Status.GetErrorText(tSC))
	}

	// Return status code for information	
	Quit tSC
}

}
