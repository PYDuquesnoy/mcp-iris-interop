/* Copyright (c) 2025 by InterSystems Corporation.
   Cambridge, Massachusetts, U.S.A.  All rights reserved.
   Confidential property of InterSystems Corporation. */

Include %occSqlfunc

/// Physical Storage Base Class
Class %Library.Storage [ Abstract, Not ProcedureBlock, System = 2 ]
{

Parameter SQLENABLED = 1;

Parameter STORAGECOMPILERCLASS = "%Compiler.Storage.Common";

/// STORAGEINTERFACE defines the type of serialization implemented by this class.
/// The value has to match the classtype of the class that is inheriting the serialization
/// interface.
Parameter STORAGEINTERFACE As STRING [ Constraint = ",persistent,serial", Flags = ENUM ];

Parameter IDTYPE;

/// <p>Builds entries for each index specified in the <var>idxlist</var> argument.
/// If <var>pIndexList</var> is empty then all indices that originate in the class are rebuilt. If no indexes 
/// are specified in <var>pIndexList</var> or there are other bitmap indexes specified in <var>pIndexList</var> 
/// and there is a bitmap extent index defined for the class and there are currently no entries in the bitmap extent index 
/// then it will be implicitly included in <var>pIndexList</var>. If there is an ID range specified in
/// <var>pStartID</var>-<var>pEndID</var> and there are either no indexes specified in <var>pIndexList</var>
/// or if indexes are specified then at least one of them is a bitmap index
/// then the bitmap extent index will be implicitly included in <var>pIndexList</var>. If the bitmap 
/// extent index is included then the bitmap extent index for each subextent is also built. </p>
/// 
/// <p>If <var>pAutoPurge</var> is true then the indices contained in <var>pIndexList</var> will be
/// purged before they are built as long as no range is specified, if a range is specified we will
/// skip any purge. The default is TRUE (1).</p>
/// 
/// <p>If <var>pLockFlag</var> is one (1) then an extent lock will be acquired before the indices
/// are built. If the lock cannot be acquired then an error is returned. The lock is released
/// after the index build is completed. If it is two (2) then a lock is acquired prior to filing 
/// indexes for that instance and it is released as soon the indexes for that instance are filed. 
/// If it is zero (0) then no locks are used while filing the indexes. If it is three (3) then it
/// an shared extent lock will be acquired before the indices are build.</p>
/// 
/// <p>If <var>pJournalFlag</var> is false then journaling is disabled for the processes used to build the 
/// indexes. If this flag is true then the journaling is enabled for the
/// process used to build the indicies. The default value of this argument is "" meaning use the current process setting. </p> 
/// 
/// <p><var>pStartID</var> and <var>pEndID</var> define a range of IDs for which indexes will be built. 
/// The range is inclusive. If the starting ID is not passed a non-null value then the range begins at the 
/// first ID defined in the extent. If the ending ID is not passed a non-null value then the range ends at the 
/// last ID defined in the extent. </p>
/// 
/// <p>If <var>pIgnoreIndexList</var> is defined, it should be a $listbuild of index names that should not be built.
/// This argument allows you to build all indices except those defined in <var>pIgnoreIndexList</var>.
/// The default value of this argument is "", which means all indices, or all indices specified in <var>pIndexList</var>, will be built. </p> 
/// 
/// <p>If <method>%OnBeforeBuildIndices</method> is implemented and is runnable then it will be called
/// just prior to purging and building any index structures. Refer to <method>%OnBeforeBuildIndices</method>
/// for more information.</p>
/// 
/// <p>If <method>%OnAfterBuildIndices</method> is implemented and is runnable then it will be called
/// after all index structures have been built completely. Refer to <method>%OnAfterBuildIndices</method>
/// for more information.</p>
/// 
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
/// This method is normally generated by the storage class for persistent classes using
/// <class>%Storage.Persistent</class> or <class>%Storage.SQL</class>.</p>
/// 
/// <p>If your index is corrupt running this function will not fix the corruption unless you rebuild the entire index
/// and purge the existing indexes. If you have inserted some new items but have deferred building the index for these
/// new items then you can run %BuildIndices on this range oif IDs to add the index entries for these new items.</p>
ClassMethod %BuildIndices(pIndexList As %RawString = "", pAutoPurge As %Integer = 1, pLockFlag As %Integer = 0, pJournalFlag As %Integer = "", pStartID As %RawString = "", pEndID As %RawString = "", pIgnoreIndexList As %RawString = "") As %Status [ ProcedureBlock = 1, ServerOnly = 0 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%BuildIndices")
}

/// This method is normally generated by the storage class for persistent classes using
/// <class>%Storage.Persistent</class> or <class>%Storage.SQL</class>. Persistent
/// classes using some other storage class, such as <class>%Library.CustomStorage</class> must override this
/// method.
ClassMethod %DeleteData(id As %String, concurrency As %Integer) As %Status [ Private, ProcedureBlock = 1, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%DeleteData")
}

/// %InitExtentData() - Initializes extent data in storage. 
/// This method is implemented by the storage class.  It simply sets the root node of the data global to ""
ClassMethod %InitExtentData() As %Status [ Private, ProcedureBlock = 1, ServerOnly = 1 ]
{
	RETURN $$$ERROR($$$MethodNotImplemented,"%Storage::%InitExtentData")
}

/// %KillExtentData() - kills extent data in storage. This method is
/// implemented by the storage class. 
/// If <var>killstreams</var> is true (default is false) it will also kill the default stream storage global.
/// If <var>reinitialize</var> is true (default is false) it will also call %InitExtent to re-define the globals.
ClassMethod %KillExtentData(killstreams As %Boolean = 0, reinitialize As %Boolean = 0) As %Status [ Private, ProcedureBlock = 1, ServerOnly = 1 ]
{
	RETURN $$$ERROR($$$MethodNotImplemented,"%Storage::%KillExtentData")
}

/// %LoadData() - loads an object from storage. This method is
/// implemented by the storage class.
Method %LoadData(id As %String) As %Status [ Private, ProcedureBlock = 1, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%LoadData")
}

/// Deletes all entries from each index specified in the <var>idxlist</var> argument.
/// If <var>idxlist</var> is empty then all indices that originate
/// in the class are purged. The index definition remains intact.
/// 
/// <p>If <var>pIgnoreIndexList</var> is defined, it should be a $listbuild of index names that should not be purged.
/// This argument allows you to purge all indices except those defined in <var>pIgnoreIndexList</var>.
/// The default value of this argument is "", which means all indices, or all indices specified in <var>pIndexList</var>, will be purged. </p> 
/// 
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
/// This method is normally generated by the storage class for persistent classes using
/// <class>%Storage.Persistent</class> or <class>%Storage.SQL</class>. Persistent
/// classes using some other storage class, such as <class>%Library.CustomStorage</class> must override this
/// method.
ClassMethod %PurgeIndices(idxlist As %List = "", lockExtent As %Boolean = 0, pIgnoreIndexList As %RawString = "") As %Status [ ProcedureBlock = 1, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%PurgeIndices")
}

/// %ValidateIndices() - Validates indices for a class
/// <br><br>
/// <b>Parameters:</b>
/// <dl>
/// <dt><i>idxList</i>
/// <dd>Optional.  "" to check all indices, or specify a $list of index names to check.  Default=""
/// <dt><i>autoCorrect</i>
/// <dd>Optional.  If true, correct any errors found.  Default=0
/// <dt><i>lockOption</i>
/// <dd>Optional.  Default = 1
///      0 - No locking is performed at all
///      1 - Shared locking as each row is checked
///      2 - exclusive lock on entire table for duration of the run
/// <dt><i>multiProcess</i>
/// <dd>Optional.  If true, parts of %ValidateIndices will use parallel processing when possible.  Default=1
/// <dt><i>verbose</i>
/// <dd>Optional.  If true, display output to the current device.  Default=1
/// <dt><i>errors</i>
/// <dd>Optional.  Passed by reference.  Returns an array of errors found in the index(es) validated.  If autoCorrect=1, this is an array of issues corrected.
/// </dl>
/// <p><b>Returns:</b>
/// <dd>Status Code</dd>
/// </p>
/// <p><b>Example</b>:
/// <li>Do $SYSTEM.OBJ.ValidateIndices("Sample.Person","",1,2)</li>
/// <li>Do $SYSTEM.OBJ.ValidateIndices("Sample.Company",$lb("NameIdx"),1,1)</li>
/// </p>
/// <p><b>Note:</b>:
/// <br>Indices may also be validated by calling the class method <i>$SYSTEM.OBJ.ValidateIndices(classname,idxList,autoCorrect,lockOption)</i>.
/// <br>There is one main difference between validating indices through <i>$SYSTEM.OBJ.ValidateIndices()</i> and <i>##class(classname).%ValidateIndices()</i>.
/// <br><i>$SYSTEM.OBJ.ValidateIndices()</i> will validate the indices for a table, and it will also validate any indices in collection child tables for that table.  
/// <br>When using <i>##class(classname).%ValidateIndices()</i>, collection child table indices must be checked with separate calls.
/// <br>Also, when calling <i>$SYSTEM.OBJ.ValidateIndices()</i>, multiProcess default is 0. When calling <i>##class(classname).%ValidateIndices()</i>, multiProcess default is 1.
/// </p>
ClassMethod %ValidateIndices(idxList As %List = "", autoCorrect As %Boolean = 0, lockOption As %Integer = 1, multiProcess As %Boolean = 1, ByRef mapList As %String, verbose As %Boolean = 1, ByRef errors As %String) As %Status [ ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%ValidateIndices")
}

/// %ValidateTable() - Validates a table's data
/// <br><br>
/// <b>Parameters:</b>
/// <dl>
/// <dt><i>lockOption</i>
/// <dd>Optional.  Default = 1
///      0 - No locking is performed at all
///      1 - Shared locking as each row is checked
///      2 - exclusive lock on entire table for duration of the run
/// <dt><i>multiProcess</i>
/// <dd>Optional.  If true, parts of %ValidateIndices will use parallel processing when possible.  Default=1
/// <dt><i>verbose</i>
/// <dd>Optional.  If true, display output to the current device.  Default=1
/// <dt><i>errors</i>
/// <dd>Optional.  Passed by reference.  Returns an array of errors found in the index(es) validated.  If autoCorrect=1, this is an array of issues corrected.
/// </dl>
/// <p><b>Returns:</b>
/// <dd>Status Code</dd>
/// </p>
/// <p><b>Example</b>:
/// <li>Do $SYSTEM.OBJ.ValidateTable("Sample.Person",1,2)</li>
/// <li>Do $SYSTEM.OBJ.ValidateTable("Sample.Company",1,1)</li>
/// </p>
ClassMethod %ValidateTable(lockOption As %Integer = 1, multiProcess As %Boolean = 1, verbose As %Boolean = 1, ByRef errors As %String) As %Status [ ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%ValidateTable")
}

/// %SaveData() - saves an object to disk, checks uniqueness and referential
/// integrity constraints, and maintains index structures. This method is
/// implemented by the storage class.
Method %SaveData(id As %String) As %Status [ Private, ProcedureBlock = 1, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SaveData")
}

/// This class just holds stub methods that will be injected into the class definition by the table
/// compiler.  No implementation details here.
ClassMethod %SQLDelete(%rowid, %check, %tstart = 1, %mv = 0, %polymorphic = 0, %bufferedColumns = 0) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLDelete")
}

ClassMethod %SQLDeleteBufferedColumns(ByRef %bufferedColumns As %Status) As %String [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLDeleteBufferedColumns")
}

ClassMethod %SQLFastInsert(%check As %Binary) As %String [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLFastInsert")
}

ClassMethod %SQLInsert(ByRef %d As %String, %check As %Binary, %inssel, %vco, %tstart = 1, %mv = 0, %bufferedColumns = 0) As %String [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLInsert")
}

ClassMethod %SQLInsertBufferedColumns(ByRef %bufferedColumns As %Status) As %String [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLInsertBufferedColumns")
}

ClassMethod %SQLUpdate(%rowid As %String, %check As %Binary, ByRef %d, %vco, %tstart = 1, %mv = 0, %polymorphic = 0, ByRef %soid As %String, ByRef %bufferedColumns As %String = 0, ByRef %bufferedColumnsDel As %String = 0) As %String [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLUpdate")
}

ClassMethod %SQLAfterTriggers() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLAfterTriggers")
}

ClassMethod %SQLAcquireLock(%rowid As %String, s As %Boolean = 0, ByRef unlockref As %String = 0) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLAcquireLock")
}

ClassMethod %SQLAcquireTableLock(s As %Boolean = 0, ByRef SQLCODE As %Integer, to As %Integer = "") [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLAcquireTableLock")
}

ClassMethod %SQLBeforeTriggers() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLBeforeTriggers")
}

ClassMethod %SQLBuildIndices(pIndices As %List = "", pLockFlag As %Integer = 0, pStartID As %RawString = "", pEndID As %RawString = "", pIgnoreIndexList As %RawString = "", pKeepSelectability As %Integer = 0) As %Status [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLBuildIndices")
}

/// %SQLBuildPurgeIndexForRow - given a list of indices (or all by default), an ID, and new and old values, purge and build the index entries for the row
/// pIndices - $listbuild of index map names to purge/build.  Default is "" and means purge/build all indices
/// pActions - A string of action characters to perform.  If pActions["P", the old index entries will be Purged/Deleted.  If pActions["B", the new index entries will be Built/Defined.  
///            The default is pActions="BP".  This can be overridden to provide a way to just Purge a row's index entries (delete) or to define a row's index entries (Insert).  Any other characters in pActions besides "B" or "P" are ignored.
/// pLockRow - 1/0 flag, default=1, 1 means acquire an exclusive, long-term lock on the row.  0 means no lock is acquired.
/// %d()     - Array subscripted by SqlColumnNumber which holds new values for indexed entries to be built
/// %e()     - Array subscripted by SqlColumnNumber which holds old values for indexed entries to be purged
/// pIgnoreIndexList - $listbuild of index map names to not purge/build.  Can be used in conjuction with pIndices to purge/build all indices except thise list.  Default is "".
/// 
ClassMethod %SQLBuildPurgeIndexForRow(pIndices As %List = "", pActions As %RawString = "BP", pLockRow As %Integer = 1, ByRef %d As %RawString, ByRef %e As %RawString, pIgnoreIndexList As %RawString = "") As %Status [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLBuildPurgeIndexForRow")
}

ClassMethod %SQLBuildPurgeIndices(pIndices As %List = "", pBuild As %Boolean, pLockFlag As %Integer = 0, pStartID As %RawString = "", pEndID As %RawString = "", pIgnoreIndexList As %RawString = "") As %Status [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLBuildPurgeIndices")
}

ClassMethod %SQLCheckUnique(pFromOrig As %Boolean = 0, %pID As %String, %pVals... As %String) As %Status [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLCheckUnique")
}

ClassMethod %SQLCheckUniqueKeys(pConNumber As %Integer, pFromOrig As %Boolean = 0, pUpdate As %Boolean = 0, pVals... As %String) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLCheckUniqueKeys")
}

ClassMethod %SQLCheckUniqueIndices(pIndices As %List, ByRef pOK As %Boolean) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLCheckUniqueIndices")
}

ClassMethod %SQLCopyIcolIntoName() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLCopyIcolIntoName")
}

ClassMethod %SQLCopyNameIntoIcol() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLCopyNameToIcol")
}

ClassMethod %SQLCreateInsDelTables(ByRef pInsTrigObj As %String, ByRef pDelTrigObj As %String) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLCreateInsDelTables")
}

ClassMethod %SQLDefineiDjVars(ByRef %d As %String, ByRef subs As %String, master As %Boolean) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLDefineiDjVars")
}

ClassMethod %SQLDeleteChildren(%parent As %String, %check As %String, ByRef sqlcode As %Integer) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLDeleteChildren")
}

ClassMethod %SQLDeleteTempStreams() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLDeleteTempStreams")
}

ClassMethod %SQLExists(pLockOnly As %Boolean = 0, ByRef pUnlockRef As %String, %pVal... As %String) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLExists")
}

ClassMethod %SQLEExit() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLEExit")
}

ClassMethod %SQLFieldValidate() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLFieldValidate")
}

ClassMethod %SQLFKeyDelLock() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLFKeyDelLock")
}

ClassMethod %SQLGetLock(pRowId As %String, pShared As %Boolean = 0, ByRef pUnlockRef As %String) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLGetLock")
}

ClassMethod %SQLGetOld(%rowid As %String, ByRef %d As %String, ByRef %e As %String, ByRef sqlcode As %Integer) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLGetOld")
}

ClassMethod %SQLGetOldAll() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLGetOldAll")
}

ClassMethod %SQLGetOldIndex(%rowid As %String, ByRef %e As %String, ByRef pF As %String = 0, ByRef sqlcode As %Integer, ByRef %buffervector As %String = 0, fld As %Integer = "") [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLGetOldIndex")
}

ClassMethod %SQLicompView() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLicompView")
}

ClassMethod %SQLInsertComputes(view As %Boolean = 0) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLInsertComputes")
}

ClassMethod %SQLInsertStreams(pVal As %String, pClassname As %String, pProperty As %String, pField As %String, pChangeEmptyToNull As %Boolean, pOIDType As %Boolean, ByRef sqlcode As %Integer, ByRef %msg As %String) [ Internal, ProcedureBlock = 1, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLInsertStreams")
}

ClassMethod %SQLInvalid(pIcol As %Integer, pVal As %String) As %Integer [ Internal, ProcedureBlock = 1, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLInvalid")
}

ClassMethod %SQLInvalid2(ficol As %Integer, val As %String, char As %String) [ Internal, ProcedureBlock = 1, PublicList = sqlcode, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLInvalid2")
}

ClassMethod %SQLMissing(fname As %String) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLmissing")
}

ClassMethod %SQLMVDelete(oref As %Binary, flags As %String, %rowid As %String, oldrec As %String) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLMVDelete")
}

ClassMethod %SQLMVIndexDelete(ByRef %e As %String) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLMVIndexDelete")
}

ClassMethod %SQLMVIndexInsert(ByRef %d As %String) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLMVIndexInsert")
}

ClassMethod %SQLMVIndexUpdate(ByRef %d As %String, ByRef %e As %String) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLMVIndexUpdate")
}

ClassMethod %SQLMVInsert(oref As %Binary, flags As %String, %rowid As %String, newrec As %String) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLMVInsert")
}

ClassMethod %SQLMVUpdate(oref As %Binary, flags As %String, %rowid As %String, newrec As %String, oldrec As %String) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLMVUpdate")
}

ClassMethod %SQLnBuild() [ Internal, ProcedureBlock = 1, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLnBuild")
}

ClassMethod %SQLNormalizeCompFields() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLNormalizeCompFields")
}

ClassMethod %SQLNormalizeFields() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLNormalizeFields")
}

ClassMethod %SQLPurgeIndices(pIndices As %List = "", pLockExtent As %Boolean = 0, pIgnoreIndexList As %RawString = "") [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLPurgeIndices")
}

ClassMethod %SQLQuickBulkInsert(%nolock As %Boolean = 0) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickBulkInsert")
}

ClassMethod %SQLQuickBulkLoad(%rowidlist As %List, %nolock As %Boolean = 0, pkey As %Boolean = 0) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickBulkLoad")
}

ClassMethod %SQLQuickBulkSave(%nolock As %Boolean = 0) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickBulkSave")
}

ClassMethod %SQLQuickBulkUpdate(%nolock As %Boolean = 0) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickBulkUpdate")
}

ClassMethod %SQLQuickDelete(%rowid As %String, %nolock As %Boolean = 0, pkey As %Boolean = 0) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickDelete")
}

ClassMethod %SQLQuickDeleteChildren(%parent As %String, %nolock As %Boolean = 0, pkey As %Boolean = 0) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickDeleteChildren")
}

ClassMethod %SQLQuickFindPKeyByRowID(%rowid As %String) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickFindPKeyByRowID")
}

ClassMethod %SQLQuickFindRowIDByPKey(pPKey As %String, pOutput As %Boolean = 1, pInternal As %Boolean = 0) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickFindRowIDByPKey")
}

ClassMethod %SQLQuickInsert(ByRef d As %String, %nolock As %Boolean = 0, pkey As %Boolean = 0, parentpkey As %Boolean = 0) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickInsert")
}

ClassMethod %SQLQuickLoad(%rowid As %List, %nolock As %Boolean = 0, pkey As %Boolean = 0, qq As %Boolean = 0) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickLoad")
}

ClassMethod %SQLQuickLoadChildren(%parref As %List, %nolock As %Boolean = 0, pkey As %Boolean = 0, returnpkey As %Boolean = 0) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickLoadChildren")
}

ClassMethod %SQLQuickLogicalToOdbc(ByRef %d As %String) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLLogicalToOdbcFields")
}

ClassMethod %SQLQuickOdbcToLogical(ByRef %d As %String) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickOdbcToLogical")
}

ClassMethod %SQLQuickUpdate(%rowid As %String, ByRef d As %String, %nolock As %Boolean = 0, pkey As %Boolean = 0) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLQuickUpdate")
}

ClassMethod %SQLReleaseLock(%rowid As %String, s As %Boolean = 0, i As %Boolean = 0, e As %Boolean = "") [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLReleaseLock")
}

ClassMethod %SQLReleaseTableLock(s As %Boolean = 0, i As %Boolean = 0) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLTableReleaseLock")
}

ClassMethod %SQLStorageValidation() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLStorageValidation")
}

ClassMethod %SQLTrigDelTab() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLTrigDelTab")
}

ClassMethod %SQLTrigInsTab() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLTrigInsTab")
}

ClassMethod %SQLUnlockError(cname As %String) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLULError")
}

ClassMethod %SQLUnlock() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLUnlock")
}

ClassMethod %SQLUnlock2() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLUnlock2")
}

ClassMethod %SQLUnlockRef() [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLUnlockRef")
}

ClassMethod %SQLUpdateComputes(view As %Boolean = 0) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLUpdateComputes")
}

ClassMethod %SQLUpdateStreams(pNew As %String, pOld As %String, pClassname As %String, pProperty As %String, pField As %String, pChangeEmptyToNull As %Boolean, pOIDType As %Boolean, ByRef sqlcode As %Integer, ByRef %msg As %String, pAllowOid As %Boolean = 0) [ Internal, ProcedureBlock = 1, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLUpdateStreams")
}

ClassMethod %SQLValidateCompFields(ByRef sqlcode As %Integer) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLValidateCompFields")
}

ClassMethod %SQLValidateFields(ByRef sqlcode As %Integer) [ Internal, ProcedureBlock = 0, ServerOnly = 1 ]
{
	QUIT $$$ERROR($$$MethodNotImplemented,"%Storage::%SQLValidateFields")
}

}
